<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Operations Visualizer</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #6b8cbc;
            --accent: #ff6b6b;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #28a745;
            --warning: #ffc107;
            --info: #17a2b8;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1s ease-out;
            position: relative;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: var(--secondary);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .nav-btn {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .nav-btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .input-section, .visualization-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            animation: slideUp 0.8s ease-out;
        }
        
        .input-section {
            animation-delay: 0.2s;
        }
        
        .visualization-section {
            animation-delay: 0.4s;
        }
        
        .section-title {
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light);
            font-size: 1.5rem;
        }
        
        .vector-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .vector-input {
            background: var(--light);
            padding: 15px;
            border-radius: 10px;
        }
        
        .vector-input h3 {
            margin-bottom: 10px;
            color: var(--secondary);
        }
        
        .coordinate-inputs {
            display: flex;
            gap: 10px;
        }
        
        .coordinate-input {
            flex: 1;
        }
        
        .coordinate-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .coordinate-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .operations-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .operation-btn {
            padding: 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .operation-btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .operation-btn.active {
            background: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .visualization-area {
            height: 300px;
            background: var(--light);
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        
        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #vectorCanvas {
            width: 100%;
            height: 100%;
        }
        
        .result-display {
            background: var(--light);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        .result-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 15px;
        }
        
        .steps-container {
            margin-top: 15px;
        }
        
        .step {
            padding: 10px;
            margin-bottom: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid var(--info);
            animation: fadeIn 0.5s ease-out;
        }
        
        .step-number {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: var(--info);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            margin-right: 10px;
            font-size: 0.9rem;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .vector-label {
            position: absolute;
            font-weight: bold;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .operation-info {
            margin-top: 20px;
            padding: 15px;
            background: #e9f7fe;
            border-radius: 10px;
            border-left: 4px solid var(--info);
        }
        
        .operation-info h4 {
            color: var(--info);
            margin-bottom: 10px;
        }
        
        .vector-representation {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
        }
        
        .vector {
            display: inline-block;
            padding: 5px 10px;
            margin: 0 10px;
            background: rgba(74, 111, 165, 0.1);
            border-radius: 5px;
        }
        
        .operation-symbol {
            font-size: 1.5rem;
            margin: 0 10px;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: var(--secondary);
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Vector Operations Visualizer</h1>
            <p class="subtitle">Visualize the top 10 vector operations with step-by-step explanations</p>
            <div class="nav-buttons">
                <a href="vectors_advanced_operations.html" class="nav-btn">Advanced Operations</a>
                <a href="vector_physics_applications.html" class="nav-btn">Vector Applications</a>
            </div>
        </header>
        
        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">Input Vectors</h2>
                
                <div class="vector-inputs">
                    <div class="vector-input">
                        <h3>Vector A</h3>
                        <div class="coordinate-inputs">
                            <div class="coordinate-input">
                                <label for="a-x">X Component</label>
                                <input type="number" id="a-x" value="3" step="0.1">
                            </div>
                            <div class="coordinate-input">
                                <label for="a-y">Y Component</label>
                                <input type="number" id="a-y" value="4" step="0.1">
                            </div>
                        </div>
                    </div>
                    
                    <div class="vector-input">
                        <h3>Vector B</h3>
                        <div class="coordinate-inputs">
                            <div class="coordinate-input">
                                <label for="b-x">X Component</label>
                                <input type="number" id="b-x" value="1" step="0.1">
                            </div>
                            <div class="coordinate-input">
                                <label for="b-y">Y Component</label>
                                <input type="number" id="b-y" value="-2" step="0.1">
                            </div>
                        </div>
                    </div>
                </div>
                
                <h2 class="section-title">Select Operation</h2>
                <div class="operations-grid">
                    <button class="operation-btn" data-operation="addition">Addition</button>
                    <button class="operation-btn" data-operation="subtraction">Subtraction</button>
                    <button class="operation-btn" data-operation="dotProduct">Dot Product</button>
                    <button class="operation-btn" data-operation="crossProduct">Cross Product</button>
                    <button class="operation-btn" data-operation="magnitude">Magnitude</button>
                    <button class="operation-btn" data-operation="normalization">Normalization</button>
                    <button class="operation-btn" data-operation="scalarMultiplication">Scalar Multiplication</button>
                    <button class="operation-btn" data-operation="angleBetween">Angle Between</button>
                    <button class="operation-btn" data-operation="projection">Projection</button>
                    <button class="operation-btn" data-operation="distance">Distance</button>
                </div>
                
                <div class="scalar-input" style="display: none; margin-top: 15px;">
                    <label for="scalar-value">Scalar Value</label>
                    <input type="number" id="scalar-value" value="2" step="0.1">
                </div>
                
                <button id="calculate-btn" style="width: 100%; padding: 15px; background: var(--accent); color: white; border: none; border-radius: 8px; font-size: 1.1rem; cursor: pointer; margin-top: 20px;">
                    Calculate & Visualize
                </button>
            </div>
            
            <div class="visualization-section">
                <h2 class="section-title">Visualization</h2>
                
                <div class="visualization-area">
                    <div class="canvas-container">
                        <canvas id="vectorCanvas"></canvas>
                    </div>
                </div>
                
                <div class="result-display">
                    <div class="result-title">Result:</div>
                    <div class="result-value" id="result-value">Select an operation and click calculate</div>
                    
                    <div class="vector-representation">
                        <span class="vector" id="vector-a">A = (3, 4)</span>
                        <span class="operation-symbol" id="operation-symbol">+</span>
                        <span class="vector" id="vector-b">B = (1, -2)</span>
                        <span class="operation-symbol">=</span>
                        <span class="vector" id="vector-result">Result</span>
                    </div>
                    
                    <div class="steps-container" id="steps-container">
                        <!-- Steps will be generated here -->
                    </div>
                </div>
                
                <div class="operation-info">
                    <h4>About this operation:</h4>
                    <p id="operation-description">Select an operation to see its description here.</p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Vector Operations Visualizer • Created with HTML, CSS, and JavaScript</p>
        </div>
    </div>

    <script>
        // DOM elements
        const operationButtons = document.querySelectorAll('.operation-btn');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultValue = document.getElementById('result-value');
        const stepsContainer = document.getElementById('steps-container');
        const operationDescription = document.getElementById('operation-description');
        const scalarInputContainer = document.querySelector('.scalar-input');
        const scalarValueInput = document.getElementById('scalar-value');
        const vectorAElement = document.getElementById('vector-a');
        const vectorBElement = document.getElementById('vector-b');
        const operationSymbol = document.getElementById('operation-symbol');
        const vectorResult = document.getElementById('vector-result');
        
        // Canvas setup
        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size to match container
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Vector class
        class Vector {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            // Vector operations
            add(v) {
                return new Vector(this.x + v.x, this.y + v.y);
            }
            
            subtract(v) {
                return new Vector(this.x - v.x, this.y - v.y);
            }
            
            dot(v) {
                return this.x * v.x + this.y * v.y;
            }
            
            cross(v) {
                return this.x * v.y - this.y * v.x;
            }
            
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector(0, 0);
                return new Vector(this.x / mag, this.y / mag);
            }
            
            scale(scalar) {
                return new Vector(this.x * scalar, this.y * scalar);
            }
            
            angleBetween(v) {
                const dotProduct = this.dot(v);
                const magProduct = this.magnitude() * v.magnitude();
                if (magProduct === 0) return 0;
                return Math.acos(dotProduct / magProduct) * (180 / Math.PI);
            }
            
            projectOnto(v) {
                const scalar = this.dot(v) / v.dot(v);
                return v.scale(scalar);
            }
            
            distanceTo(v) {
                return this.subtract(v).magnitude();
            }
        }
        
        // Current vectors and operation
        let vectorA = new Vector(3, 4);
        let vectorB = new Vector(1, -2);
        let currentOperation = 'addition';
        let scalarValue = 2;
        
        // Operation descriptions
        const operationDescriptions = {
            addition: "Vector addition is performed by adding corresponding components. Geometrically, it represents the diagonal of the parallelogram formed by the two vectors.",
            subtraction: "Vector subtraction is performed by subtracting corresponding components. Geometrically, it represents the vector from the tip of the second vector to the tip of the first.",
            dotProduct: "The dot product (or scalar product) measures the similarity between two vectors. It's calculated by multiplying corresponding components and summing the results.",
            crossProduct: "In 2D, the cross product returns a scalar representing the signed area of the parallelogram spanned by the two vectors. A positive value indicates counterclockwise orientation.",
            magnitude: "The magnitude (or length) of a vector is calculated using the Pythagorean theorem. It represents the distance from the origin to the point defined by the vector.",
            normalization: "Normalization creates a unit vector (length 1) in the same direction as the original vector. This is done by dividing each component by the vector's magnitude.",
            scalarMultiplication: "Scalar multiplication scales a vector by a real number. Each component is multiplied by the scalar, changing the vector's length but not its direction (unless the scalar is negative).",
            angleBetween: "The angle between two vectors is calculated using the dot product formula. It represents the smallest angle needed to rotate one vector to align with the other.",
            projection: "The projection of vector A onto vector B is the component of A that lies in the direction of B. It's calculated using the dot product and scaling.",
            distance: "The distance between two vectors is the length of the vector connecting their endpoints. It's calculated as the magnitude of their difference."
        };
        
        // Initialize with first operation selected
        operationButtons[0].classList.add('active');
        operationDescription.textContent = operationDescriptions[currentOperation];
        
        // Event listeners
        operationButtons.forEach(button => {
            button.addEventListener('click', () => {
                operationButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentOperation = button.dataset.operation;
                operationDescription.textContent = operationDescriptions[currentOperation];
                
                // Show/hide scalar input based on operation
                if (currentOperation === 'scalarMultiplication') {
                    scalarInputContainer.style.display = 'block';
                } else {
                    scalarInputContainer.style.display = 'none';
                }
            });
        });
        
        calculateBtn.addEventListener('click', calculateOperation);
        
        // Input change handlers
        document.getElementById('a-x').addEventListener('input', updateVectors);
        document.getElementById('a-y').addEventListener('input', updateVectors);
        document.getElementById('b-x').addEventListener('input', updateVectors);
        document.getElementById('b-y').addEventListener('input', updateVectors);
        scalarValueInput.addEventListener('input', updateScalar);
        
        function updateVectors() {
            vectorA = new Vector(
                parseFloat(document.getElementById('a-x').value) || 0,
                parseFloat(document.getElementById('a-y').value) || 0
            );
            
            vectorB = new Vector(
                parseFloat(document.getElementById('b-x').value) || 0,
                parseFloat(document.getElementById('b-y').value) || 0
            );
            
            // Update vector representations
            vectorAElement.textContent = `A = (${vectorA.x}, ${vectorA.y})`;
            vectorBElement.textContent = `B = (${vectorB.x}, ${vectorB.y})`;
            
            calculateOperation();
        }
        
        function updateScalar() {
            scalarValue = parseFloat(scalarValueInput.value) || 0;
            calculateOperation();
        }
        
        // Calculate the selected operation
        function calculateOperation() {
            let result;
            let steps = [];
            
            // Update operation symbol
            switch(currentOperation) {
                case 'addition': operationSymbol.textContent = '+'; break;
                case 'subtraction': operationSymbol.textContent = '-'; break;
                case 'dotProduct': operationSymbol.textContent = '•'; break;
                case 'crossProduct': operationSymbol.textContent = '×'; break;
                case 'magnitude': operationSymbol.textContent = '|A|'; break;
                case 'normalization': operationSymbol.textContent = 'Â'; break;
                case 'scalarMultiplication': operationSymbol.textContent = '×'; break;
                case 'angleBetween': operationSymbol.textContent = '∠'; break;
                case 'projection': operationSymbol.textContent = 'proj'; break;
                case 'distance': operationSymbol.textContent = 'd'; break;
            }
            
            // Perform the selected operation
            switch(currentOperation) {
                case 'addition':
                    result = vectorA.add(vectorB);
                    steps = [
                        `Vector addition is performed component-wise.`,
                        `A + B = (${vectorA.x} + ${vectorB.x}, ${vectorA.y} + ${vectorB.y})`,
                        `A + B = (${vectorA.x + vectorB.x}, ${vectorA.y + vectorB.y})`,
                        `The result is a new vector with components (${result.x}, ${result.y}).`,
                        `Geometrically, this is the diagonal of the parallelogram formed by A and B.`
                    ];
                    vectorResult.textContent = `(${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                    break;
                    
                case 'subtraction':
                    result = vectorA.subtract(vectorB);
                    steps = [
                        `Vector subtraction is performed component-wise.`,
                        `A - B = (${vectorA.x} - ${vectorB.x}, ${vectorA.y} - ${vectorB.y})`,
                        `A - B = (${vectorA.x - vectorB.x}, ${vectorA.y - vectorB.y})`,
                        `The result is a new vector with components (${result.x}, ${result.y}).`,
                        `Geometrically, this vector points from B to A.`
                    ];
                    vectorResult.textContent = `(${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                    break;
                    
                case 'dotProduct':
                    result = vectorA.dot(vectorB);
                    steps = [
                        `The dot product is calculated as A • B = AₓBₓ + AᵧBᵧ.`,
                        `A • B = (${vectorA.x} × ${vectorB.x}) + (${vectorA.y} × ${vectorB.y})`,
                        `A • B = ${vectorA.x * vectorB.x} + ${vectorA.y * vectorB.y}`,
                        `A • B = ${result}`,
                        `This scalar value measures the alignment of the two vectors.`
                    ];
                    vectorResult.textContent = result.toFixed(2);
                    break;
                    
                case 'crossProduct':
                    result = vectorA.cross(vectorB);
                    steps = [
                        `In 2D, the cross product is calculated as A × B = AₓBᵧ - AᵧBₓ.`,
                        `A × B = (${vectorA.x} × ${vectorB.y}) - (${vectorA.y} × ${vectorB.x})`,
                        `A × B = ${vectorA.x * vectorB.y} - ${vectorA.y * vectorB.x}`,
                        `A × B = ${result}`,
                        `This scalar represents the signed area of the parallelogram spanned by A and B.`
                    ];
                    vectorResult.textContent = result.toFixed(2);
                    break;
                    
                case 'magnitude':
                    result = vectorA.magnitude();
                    steps = [
                        `The magnitude is calculated using the Pythagorean theorem.`,
                        `|A| = √(Aₓ² + Aᵧ²)`,
                        `|A| = √(${vectorA.x}² + ${vectorA.y}²)`,
                        `|A| = √(${vectorA.x * vectorA.x} + ${vectorA.y * vectorA.y})`,
                        `|A| = √(${vectorA.x * vectorA.x + vectorA.y * vectorA.y}) = ${result.toFixed(2)}`
                    ];
                    vectorResult.textContent = result.toFixed(2);
                    break;
                    
                case 'normalization':
                    result = vectorA.normalize();
                    const mag = vectorA.magnitude();
                    steps = [
                        `A unit vector in the direction of A is calculated as Â = A / |A|.`,
                        `First, calculate |A| = √(${vectorA.x}² + ${vectorA.y}²) = ${mag.toFixed(2)}`,
                        `Then, Â = (${vectorA.x}/${mag.toFixed(2)}, ${vectorA.y}/${mag.toFixed(2)})`,
                        `Â = (${(vectorA.x/mag).toFixed(2)}, ${(vectorA.y/mag).toFixed(2)})`,
                        `The result is a vector with the same direction but length 1.`
                    ];
                    vectorResult.textContent = `(${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                    break;
                    
                case 'scalarMultiplication':
                    result = vectorA.scale(scalarValue);
                    steps = [
                        `Scalar multiplication scales each component by the scalar value.`,
                        `${scalarValue} × A = (${scalarValue} × ${vectorA.x}, ${scalarValue} × ${vectorA.y})`,
                        `${scalarValue} × A = (${scalarValue * vectorA.x}, ${scalarValue * vectorA.y})`,
                        `The result is a new vector with components (${result.x}, ${result.y}).`,
                        `This operation changes the vector's length but not its direction.`
                    ];
                    vectorResult.textContent = `(${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                    break;
                    
                case 'angleBetween':
                    result = vectorA.angleBetween(vectorB);
                    const dot = vectorA.dot(vectorB);
                    const magA = vectorA.magnitude();
                    const magB = vectorB.magnitude();
                    steps = [
                        `The angle between vectors is calculated using: cos(θ) = (A • B) / (|A| |B|)`,
                        `First, calculate A • B = ${dot.toFixed(2)}, |A| = ${magA.toFixed(2)}, |B| = ${magB.toFixed(2)}`,
                        `Then, cos(θ) = ${dot.toFixed(2)} / (${magA.toFixed(2)} × ${magB.toFixed(2)})`,
                        `cos(θ) = ${dot.toFixed(2)} / ${(magA * magB).toFixed(2)} = ${(dot/(magA*magB)).toFixed(2)}`,
                        `θ = cos⁻¹(${(dot/(magA*magB)).toFixed(2)}) = ${result.toFixed(2)}°`
                    ];
                    vectorResult.textContent = `${result.toFixed(2)}°`;
                    break;
                    
                case 'projection':
                    result = vectorA.projectOnto(vectorB);
                    const scalarProj = vectorA.dot(vectorB) / vectorB.dot(vectorB);
                    steps = [
                        `The projection of A onto B is calculated as: proj_B A = [(A • B) / (B • B)] × B`,
                        `First, calculate A • B = ${vectorA.dot(vectorB).toFixed(2)}, B • B = ${vectorB.dot(vectorB).toFixed(2)}`,
                        `Then, scalar = (A • B) / (B • B) = ${vectorA.dot(vectorB).toFixed(2)} / ${vectorB.dot(vectorB).toFixed(2)} = ${scalarProj.toFixed(2)}`,
                        `Finally, multiply B by this scalar: ${scalarProj.toFixed(2)} × (${vectorB.x}, ${vectorB.y})`,
                        `proj_B A = (${result.x.toFixed(2)}, ${result.y.toFixed(2)})`
                    ];
                    vectorResult.textContent = `(${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                    break;
                    
                case 'distance':
                    result = vectorA.distanceTo(vectorB);
                    const diff = vectorA.subtract(vectorB);
                    steps = [
                        `The distance between A and B is the magnitude of their difference: d = |A - B|`,
                        `First, calculate A - B = (${vectorA.x} - ${vectorB.x}, ${vectorA.y} - ${vectorB.y})`,
                        `A - B = (${diff.x}, ${diff.y})`,
                        `Then, d = √((${diff.x})² + (${diff.y})²)`,
                        `d = √(${diff.x * diff.x} + ${diff.y * diff.y}) = √${diff.x * diff.x + diff.y * diff.y} = ${result.toFixed(2)}`
                    ];
                    vectorResult.textContent = result.toFixed(2);
                    break;
            }
            
            // Update result display
            if (typeof result === 'number') {
                resultValue.textContent = result.toFixed(2);
            } else if (result instanceof Vector) {
                resultValue.textContent = `(${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
            }
            
            // Update steps
            stepsContainer.innerHTML = '';
            steps.forEach((step, index) => {
                const stepElement = document.createElement('div');
                stepElement.className = 'step';
                stepElement.innerHTML = `<span class="step-number">${index + 1}</span>${step}`;
                stepsContainer.appendChild(stepElement);
            });
            
            // Draw visualization
            drawVectors();
        }
        
        // Draw vectors on canvas
        function drawVectors() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set origin to center of canvas
            const originX = canvas.width / 2;
            const originY = canvas.height / 2;
            
            // Scale factor to fit vectors in canvas
            const scale = Math.min(canvas.width, canvas.height) / 6;
            
            // Draw grid
            drawGrid(originX, originY, scale);
            
            // Draw coordinate axes
            drawAxes(originX, originY);
            
            // Draw vectors based on operation
            switch(currentOperation) {
                case 'addition':
                    drawVectorAddition(originX, originY, scale);
                    break;
                case 'subtraction':
                    drawVectorSubtraction(originX, originY, scale);
                    break;
                case 'dotProduct':
                    drawDotProduct(originX, originY, scale);
                    break;
                case 'crossProduct':
                    drawCrossProduct(originX, originY, scale);
                    break;
                case 'magnitude':
                    drawMagnitude(originX, originY, scale);
                    break;
                case 'normalization':
                    drawNormalization(originX, originY, scale);
                    break;
                case 'scalarMultiplication':
                    drawScalarMultiplication(originX, originY, scale);
                    break;
                case 'angleBetween':
                    drawAngleBetween(originX, originY, scale);
                    break;
                case 'projection':
                    drawProjection(originX, originY, scale);
                    break;
                case 'distance':
                    drawDistance(originX, originY, scale);
                    break;
            }
        }
        
        // Draw grid
        function drawGrid(originX, originY, scale) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // Vertical lines
            for (let x = originX % scale; x < canvas.width; x += scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = originY % scale; y < canvas.height; y += scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }
        
        // Draw coordinate axes
        function drawAxes(originX, originY) {
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(canvas.width, originY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, canvas.height);
            ctx.stroke();
        }
        
        // Draw a vector with arrowhead
        function drawVector(x, y, vector, color, label, scale = 1) {
            const scaledX = vector.x * scale;
            const scaledY = -vector.y * scale; // Invert Y for canvas coordinates
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + scaledX, y + scaledY);
            ctx.stroke();
            
            // Draw arrowhead
            const angle = Math.atan2(scaledY, scaledX);
            const arrowLength = 10;
            
            ctx.beginPath();
            ctx.moveTo(x + scaledX, y + scaledY);
            ctx.lineTo(
                x + scaledX - arrowLength * Math.cos(angle - Math.PI/6),
                y + scaledY - arrowLength * Math.sin(angle - Math.PI/6)
            );
            ctx.lineTo(
                x + scaledX - arrowLength * Math.cos(angle + Math.PI/6),
                y + scaledY - arrowLength * Math.sin(angle + Math.PI/6)
            );
            ctx.closePath();
            ctx.fill();
            
            // Draw label
            ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(
                label, 
                x + scaledX/2 + 5, 
                y + scaledY/2 - 5
            );
        }
        
        // Specific drawing functions for each operation
        function drawVectorAddition(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw vector B from tip of A (parallelogram rule)
            drawVector(originX + vectorA.x * scale, originY - vectorA.y * scale, vectorB, '#6b8cbc', '', scale);
            
            // Draw resultant vector
            const result = vectorA.add(vectorB);
            drawVector(originX, originY, result, '#ff6b6b', 'A+B', scale);
            
            // Draw dashed lines for parallelogram
            ctx.strokeStyle = '#6b8cbc';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(originX + vectorA.x * scale, originY - vectorA.y * scale);
            ctx.lineTo(originX + result.x * scale, originY - result.y * scale);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(originX + vectorB.x * scale, originY - vectorB.y * scale);
            ctx.lineTo(originX + result.x * scale, originY - result.y * scale);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawVectorSubtraction(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw vector -B
            const negativeB = new Vector(-vectorB.x, -vectorB.y);
            drawVector(originX, originY, negativeB, '#6b8cbc', '-B', scale);
            
            // Draw resultant vector A - B
            const result = vectorA.subtract(vectorB);
            drawVector(originX, originY, result, '#ff6b6b', 'A-B', scale);
            
            // Draw dashed line from B to A
            ctx.strokeStyle = '#ff6b6b';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(originX + vectorB.x * scale, originY - vectorB.y * scale);
            ctx.lineTo(originX + vectorA.x * scale, originY - vectorA.y * scale);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawDotProduct(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw projection lines
            ctx.strokeStyle = '#aaa';
            ctx.setLineDash([3, 3]);
            
            // From tip of A to B's line
            ctx.beginPath();
            ctx.moveTo(originX + vectorA.x * scale, originY - vectorA.y * scale);
            ctx.lineTo(
                originX + (vectorA.dot(vectorB) / (vectorB.magnitude() * vectorB.magnitude())) * vectorB.x * scale,
                originY - (vectorA.dot(vectorB) / (vectorB.magnitude() * vectorB.magnitude())) * vectorB.y * scale
            );
            ctx.stroke();
            
            // From tip of B to A's line
            ctx.beginPath();
            ctx.moveTo(originX + vectorB.x * scale, originY - vectorB.y * scale);
            ctx.lineTo(
                originX + (vectorB.dot(vectorA) / (vectorA.magnitude() * vectorA.magnitude())) * vectorA.x * scale,
                originY - (vectorB.dot(vectorA) / (vectorA.magnitude() * vectorA.magnitude())) * vectorA.y * scale
            );
            ctx.stroke();
            
            ctx.setLineDash([]);
            
            // Display dot product value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `A • B = ${vectorA.dot(vectorB).toFixed(2)}`, 
                originX + 10, 
                originY + 30
            );
        }
        
        function drawCrossProduct(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw parallelogram
            ctx.strokeStyle = '#ff6b6b';
            ctx.fillStyle = 'rgba(255, 107, 107, 0.2)';
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + vectorA.x * scale, originY - vectorA.y * scale);
            ctx.lineTo(
                originX + (vectorA.x + vectorB.x) * scale, 
                originY - (vectorA.y + vectorB.y) * scale
            );
            ctx.lineTo(originX + vectorB.x * scale, originY - vectorB.y * scale);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Display cross product value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `A × B = ${vectorA.cross(vectorB).toFixed(2)}`, 
                originX + 10, 
                originY + 30
            );
        }
        
        function drawMagnitude(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw magnitude line
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + vectorA.x * scale, originY - vectorA.y * scale);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Display magnitude value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `|A| = ${vectorA.magnitude().toFixed(2)}`, 
                originX + vectorA.x * scale / 2 + 10, 
                originY - vectorA.y * scale / 2 - 10
            );
        }
        
        function drawNormalization(originX, originY, scale) {
            // Draw original vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw unit vector
            const unitVector = vectorA.normalize();
            drawVector(originX, originY, unitVector, '#ff6b6b', 'Â', scale * 2); // Scale up for visibility
            
            // Draw unit circle
            ctx.strokeStyle = '#aaa';
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.arc(originX, originY, scale * 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Display unit vector value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `Â = (${unitVector.x.toFixed(2)}, ${unitVector.y.toFixed(2)})`, 
                originX + 10, 
                originY + 30
            );
        }
        
        function drawScalarMultiplication(originX, originY, scale) {
            // Draw original vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw scaled vector
            const scaledVector = vectorA.scale(scalarValue);
            drawVector(originX, originY, scaledVector, '#ff6b6b', `${scalarValue}A`, scale);
            
            // Display scaled vector value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `${scalarValue} × A = (${scaledVector.x.toFixed(2)}, ${scaledVector.y.toFixed(2)})`, 
                originX + 10, 
                originY + 30
            );
        }
        
        function drawAngleBetween(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw angle arc
            const angle = vectorA.angleBetween(vectorB) * Math.PI / 180;
            const startAngle = Math.atan2(-vectorB.y, vectorB.x);
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(originX, originY, scale * 0.7, startAngle, startAngle + angle, angle < 0);
            ctx.stroke();
            
            // Display angle value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `θ = ${vectorA.angleBetween(vectorB).toFixed(2)}°`, 
                originX + 10, 
                originY + 30
            );
        }
        
        function drawProjection(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw projection of A onto B
            const projection = vectorA.projectOnto(vectorB);
            drawVector(originX, originY, projection, '#ff6b6b', 'proj_B A', scale);
            
            // Draw dashed line from A to projection
            ctx.strokeStyle = '#aaa';
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(
                originX + vectorA.x * scale, 
                originY - vectorA.y * scale
            );
            ctx.lineTo(
                originX + projection.x * scale, 
                originY - projection.y * scale
            );
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Display projection value
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `proj_B A = (${projection.x.toFixed(2)}, ${projection.y.toFixed(2)})`, 
                originX + 10, 
                originY + 30
            );
        }
        
        function drawDistance(originX, originY, scale) {
            // Draw vector A
            drawVector(originX, originY, vectorA, '#4a6fa5', 'A', scale);
            
            // Draw vector B
            drawVector(originX, originY, vectorB, '#6b8cbc', 'B', scale);
            
            // Draw distance line between A and B
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(
                originX + vectorA.x * scale, 
                originY - vectorA.y * scale
            );
            ctx.lineTo(
                originX + vectorB.x * scale, 
                originY - vectorB.y * scale
            );
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Display distance value
            const distance = vectorA.distanceTo(vectorB);
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '16px Arial';
            ctx.fillText(
                `d = ${distance.toFixed(2)}`, 
                originX + (vectorA.x + vectorB.x) * scale / 2 + 10, 
                originY - (vectorA.y + vectorB.y) * scale / 2 - 10
            );
        }
        
        // Initialize
        updateVectors();
    </script>
</body>
</html>