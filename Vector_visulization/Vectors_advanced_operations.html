<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Vector Operations</title>
    <style>
        :root {
            --primary: #4a6fa5;
            --secondary: #6b8cbc;
            --accent: #ff6b6b;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #28a745;
            --warning: #ffc107;
            --info: #17a2b8;
            --purple: #6f42c1;
            --teal: #20c997;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            animation: fadeIn 1s ease-out;
            position: relative;
        }
        
        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }
        
        .subtitle {
            color: var(--secondary);
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }
        
        .nav-btn {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .nav-btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        @media (max-width: 1100px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
        
        .input-section, .visualization-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            animation: slideUp 0.8s ease-out;
        }
        
        .input-section {
            animation-delay: 0.2s;
        }
        
        .visualization-section {
            animation-delay: 0.4s;
        }
        
        .section-title {
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light);
            font-size: 1.5rem;
        }
        
        .vector-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .vector-inputs {
                grid-template-columns: 1fr;
            }
        }
        
        .vector-input {
            background: var(--light);
            padding: 15px;
            border-radius: 10px;
        }
        
        .vector-input h3 {
            margin-bottom: 10px;
            color: var(--secondary);
        }
        
        .coordinate-inputs {
            display: flex;
            gap: 10px;
        }
        
        .coordinate-input {
            flex: 1;
        }
        
        .coordinate-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .coordinate-input input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 1rem;
        }
        
        .operations-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 768px) {
            .operations-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .operation-btn {
            padding: 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .operation-btn:hover {
            background: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .operation-btn.active {
            background: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        .visualization-area {
            height: 400px;
            background: var(--light);
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        
        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #vectorCanvas {
            width: 100%;
            height: 100%;
        }
        
        .result-display {
            background: var(--light);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .result-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary);
        }
        
        .result-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 15px;
        }
        
        .steps-container {
            margin-top: 15px;
        }
        
        .step {
            padding: 10px;
            margin-bottom: 10px;
            background: white;
            border-radius: 5px;
            border-left: 4px solid var(--info);
            animation: fadeIn 0.5s ease-out;
        }
        
        .step-number {
            display: inline-block;
            width: 25px;
            height: 25px;
            background: var(--info);
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 25px;
            margin-right: 10px;
            font-size: 0.9rem;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .vector-label {
            position: absolute;
            font-weight: bold;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .operation-info {
            margin-top: 20px;
            padding: 15px;
            background: #e9f7fe;
            border-radius: 10px;
            border-left: 4px solid var(--info);
        }
        
        .operation-info h4 {
            color: var(--info);
            margin-bottom: 10px;
        }
        
        .vector-representation {
            display: flex;
            justify-content: center;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            flex-wrap: wrap;
        }
        
        .vector {
            display: inline-block;
            padding: 5px 10px;
            margin: 0 10px;
            background: rgba(74, 111, 165, 0.1);
            border-radius: 5px;
        }
        
        .operation-symbol {
            font-size: 1.5rem;
            margin: 0 10px;
        }
        
        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: var(--secondary);
            font-size: 0.9rem;
        }
        
        /* 3D Canvas Controls */
        .canvas-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            justify-content: center;
        }
        
        .control-btn {
            padding: 8px 15px;
            background: var(--secondary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        /* Additional input sections */
        .additional-inputs {
            margin-top: 15px;
            display: none;
        }
        
        .additional-inputs.active {
            display: block;
            animation: fadeIn 0.5s ease-out;
        }
        
        .triple-vector-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        @media (max-width: 768px) {
            .triple-vector-inputs {
                grid-template-columns: 1fr;
            }
        }
        
        .multi-vector-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        @media (max-width: 768px) {
            .multi-vector-inputs {
                grid-template-columns: 1fr;
            }
        }
        
        .color-indicator {
            display: inline-block;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .color-a { background-color: #4a6fa5; }
        .color-b { background-color: #6b8cbc; }
        .color-c { background-color: #6f42c1; }
        .color-result { background-color: #ff6b6b; }
        
        /* New styles for advanced features */
        .physics-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .matrix-input-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        
        .matrix-input {
            width: 100%;
            padding: 5px;
            text-align: center;
        }
        
        .curve-control-points {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 10px 0;
        }
        
        .field-expression {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
        }
        
        .simulation-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        
        .sim-btn {
            padding: 8px 15px;
            background: var(--teal);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .data-points-input {
            width: 100%;
            height: 60px;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: monospace;
            resize: vertical;
        }
       /* AI Features Styles */
.ai-features-section {
    background: rgba(248, 249, 250, 0.8);
    padding: 20px;
    border-radius: 10px;
    margin-top: 20px;
    border-left: 4px solid var(--teal);
}

.suggestions-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin: 15px 0;
}

.suggestion-chip {
    padding: 8px 15px;
    background: var(--light);
    border: 1px solid var(--secondary);
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.3s ease;
}

.suggestion-chip:hover {
    background: var(--secondary);
    color: white;
    transform: translateY(-2px);
}

.command-buttons {
    display: flex;
    gap: 10px;
}

.ai-explanation-box {
    background: white;
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid var(--info);
    font-size: 0.95rem;
    line-height: 1.5;
}

.toggle-switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 30px;
    margin-right: 10px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: .4s;
    border-radius: 30px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: var(--teal);
}

input:checked + .slider:before {
    transform: translateX(30px);
}

.command-examples {
    font-size: 0.8rem;
    color: var(--secondary);
    margin-top: 5px;
}

.recording {
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { background-color: var(--teal); }
    50% { background-color: var(--accent); }
    100% { background-color: var(--teal); }
} 
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Advanced Vector Operations</h1>
            <p class="subtitle">Explore advanced vector operations with 3D visualization and specialized transformations</p>
            <div class="nav-buttons">
                <a href="Vector_visulization.html" class="nav-btn">Back to Basic Operations</a>
                <button id="toggle-3d" class="nav-btn">Toggle 2D/3D View</button>
                <a href="vector_physics_applications.html" class="nav-btn">Vector Applications</a>
            </div>
        </header>
       <!-- Add this after the operations grid but before the calculate button -->
<div class="ai-features-section">
    <h2 class="section-title">AI-Powered Features</h2>
    
    <!-- AI Suggestions -->
    <div class="ai-suggestions">
        <h3>🤖 AI Operation Suggestions</h3>
        <div id="ai-suggestions-list" class="suggestions-list">
            <!-- AI suggestions will appear here -->
        </div>
        <button id="get-suggestions" class="nav-btn" style="margin-top: 10px;">Get AI Suggestions</button>
    </div>
    
    <!-- Natural Language Input -->
    <div class="natural-language-input" style="margin-top: 20px;">
        <h3>🎤 Natural Language Command</h3>
        <div class="command-input-container">
            <input type="text" id="nl-command" placeholder="Try: 'Rotate vector A 45 degrees around Z-axis'" 
                   style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px;">
            <div class="command-buttons">
                <button id="voice-command" class="nav-btn" style="background: var(--teal);">🎤 Voice</button>
                <button id="execute-command" class="nav-btn" style="background: var(--purple);">Execute</button>
                <button id="clear-command" class="nav-btn" style="background: var(--secondary);">Clear</button>
            </div>
        </div>
        <div id="command-feedback" style="margin-top: 10px; font-size: 0.9rem; color: var(--secondary);"></div>
    </div>
    
    <!-- AI Explanations Toggle -->
    <div class="ai-explanations-toggle" style="margin-top: 20px;">
        <h3>📚 AI-Powered Explanations</h3>
        <label class="toggle-switch">
            <input type="checkbox" id="ai-explanations-toggle">
            <span class="slider"></span>
            Enable Detailed AI Explanations
        </label>
        <div id="ai-explanation" class="ai-explanation-box" style="display: none; margin-top: 10px;">
            <!-- AI-generated explanation will appear here -->
        </div>
    </div>
</div>
 
        <div class="main-content">
            <div class="input-section">
                <h2 class="section-title">Input Vectors</h2>
                
                <div class="vector-inputs">
                    <div class="vector-input">
                        <h3><span class="color-indicator color-a"></span>Vector A</h3>
                        <div class="coordinate-inputs">
                            <div class="coordinate-input">
                                <label for="a-x">X Component</label>
                                <input type="number" id="a-x" value="3" step="0.1">
                            </div>
                            <div class="coordinate-input">
                                <label for="a-y">Y Component</label>
                                <input type="number" id="a-y" value="4" step="0.1">
                            </div>
                            <div class="coordinate-input">
                                <label for="a-z">Z Component</label>
                                <input type="number" id="a-z" value="2" step="0.1">
                            </div>
                        </div>
                    </div>
                    
                    <div class="vector-input">
                        <h3><span class="color-indicator color-b"></span>Vector B</h3>
                        <div class="coordinate-inputs">
                            <div class="coordinate-input">
                                <label for="b-x">X Component</label>
                                <input type="number" id="b-x" value="1" step="0.1">
                            </div>
                            <div class="coordinate-input">
                                <label for="b-y">Y Component</label>
                                <input type="number" id="b-y" value="-2" step="0.1">
                            </div>
                            <div class="coordinate-input">
                                <label for="b-z">Z Component</label>
                                <input type="number" id="b-z" value="3" step="0.1">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Additional vector inputs for specific operations -->
                <div class="additional-inputs" id="third-vector-input">
                    <h3><span class="color-indicator color-c"></span>Vector C</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="c-x">X Component</label>
                            <input type="number" id="c-x" value="0" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="c-y">Y Component</label>
                            <input type="number" id="c-y" value="3" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="c-z">Z Component</label>
                            <input type="number" id="c-z" value="-1" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="axis-input">
                    <h3>Reflection Axis / Plane Normal</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="axis-x">X Component</label>
                            <input type="number" id="axis-x" value="1" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="axis-y">Y Component</label>
                            <input type="number" id="axis-y" value="0" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="axis-z">Z Component</label>
                            <input type="number" id="axis-z" value="0" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="point-input">
                    <h3>Point P (for Barycentric Coordinates)</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="p-x">X Coordinate</label>
                            <input type="number" id="p-x" value="1.5" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="p-y">Y Coordinate</label>
                            <input type="number" id="p-y" value="2" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="p-z">Z Coordinate</label>
                            <input type="number" id="p-z" value="1" step="0.1">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="angle-input">
                    <h3>Rotation Angle (degrees)</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <input type="number" id="angle-value" value="45" step="1">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="shear-input">
                    <h3>Shear Factors</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="shear-x">X Factor</label>
                            <input type="number" id="shear-x" value="0.5" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="shear-y">Y Factor</label>
                            <input type="number" id="shear-y" value="0" step="0.1">
                        </div>
                    </div>
                </div>
                
                <!-- New inputs for advanced features -->
                <div class="additional-inputs" id="physics-input">
                    <h3>Physics Parameters</h3>
                    <div class="physics-controls">
                        <div class="coordinate-input">
                            <label for="mass-value">Mass</label>
                            <input type="number" id="mass-value" value="1" step="0.1" min="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="gravity-value">Gravity</label>
                            <input type="number" id="gravity-value" value="9.8" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="spring-constant">Spring Constant</label>
                            <input type="number" id="spring-constant" value="0.5" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="damping">Damping</label>
                            <input type="number" id="damping" value="0.1" step="0.01" min="0" max="1">
                        </div>
                    </div>
                    <div class="simulation-controls">
                        <button id="start-sim" class="sim-btn">Start Simulation</button>
                        <button id="pause-sim" class="sim-btn">Pause</button>
                        <button id="reset-sim" class="sim-btn">Reset</button>
                    </div>
                </div>
                
                <div class="additional-inputs" id="quaternion-input">
                    <h3>Quaternion Parameters</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="quat-w">W Component</label>
                            <input type="number" id="quat-w" value="1" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="quat-x">X Component</label>
                            <input type="number" id="quat-x" value="0" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="quat-y">Y Component</label>
                            <input type="number" id="quat-y" value="0" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="quat-z">Z Component</label>
                            <input type="number" id="quat-z" value="0" step="0.1">
                        </div>
                    </div>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="slerp-factor">SLERP Factor (0-1)</label>
                            <input type="number" id="slerp-factor" value="0.5" step="0.1" min="0" max="1">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="matrix-input">
                    <h3>Matrix Input (for Eigen Decomposition)</h3>
                    <div class="matrix-input-grid">
                        <input type="number" id="m11" value="2" step="0.1" class="matrix-input">
                        <input type="number" id="m12" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="m13" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="m21" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="m22" value="3" step="0.1" class="matrix-input">
                        <input type="number" id="m23" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="m31" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="m32" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="m33" value="2" step="0.1" class="matrix-input">
                    </div>
                </div>
                
                <div class="additional-inputs" id="transform-matrix-input">
                    <h3>Transformation Matrix (4x4)</h3>
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; margin: 10px 0;">
                        <input type="number" id="t11" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="t12" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t13" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t14" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t21" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t22" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="t23" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t24" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t31" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t32" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t33" value="1" step="0.1" class="matrix-input">
                        <input type="number" id="t34" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t41" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t42" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t43" value="0" step="0.1" class="matrix-input">
                        <input type="number" id="t44" value="1" step="0.1" class="matrix-input">
                    </div>
                </div>
                
                <div class="additional-inputs" id="vector-field-input">
                    <h3>Vector Field Definition</h3>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="field-type">Field Type</label>
                            <select id="field-type" class="coordinate-input">
                                <option value="rotation">Rotation: F(x,y) = (-y, x)</option>
                                <option value="gravity">Gravity: F(x,y) = (0, -9.8)</option>
                                <option value="custom">Custom Expression</option>
                            </select>
                        </div>
                    </div>
                    <div class="coordinate-input">
                        <label for="custom-field">Custom Field (JavaScript)</label>
                        <input type="text" id="custom-field" value="return {x: -y, y: x};" class="field-expression">
                    </div>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="field-resolution">Resolution</label>
                            <input type="number" id="field-resolution" value="10" min="5" max="20">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="curve-input">
                    <h3>Curve Control Points</h3>
                    <div class="curve-control-points">
                        <div class="coordinate-input">
                            <label for="cp1-x">P1 X</label>
                            <input type="number" id="cp1-x" value="0" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp1-y">P1 Y</label>
                            <input type="number" id="cp1-y" value="0" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp2-x">P2 X</label>
                            <input type="number" id="cp2-x" value="1" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp2-y">P2 Y</label>
                            <input type="number" id="cp2-y" value="2" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp3-x">P3 X</label>
                            <input type="number" id="cp3-x" value="2" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp3-y">P3 Y</label>
                            <input type="number" id="cp3-y" value="1" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp4-x">P4 X</label>
                            <input type="number" id="cp4-x" value="3" step="0.1">
                        </div>
                        <div class="coordinate-input">
                            <label for="cp4-y">P4 Y</label>
                            <input type="number" id="cp4-y" value="0" step="0.1">
                        </div>
                    </div>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="curve-segments">Segments</label>
                            <input type="number" id="curve-segments" value="50" min="10" max="200">
                        </div>
                    </div>
                </div>
                
                <div class="additional-inputs" id="pca-input">
                    <h3>PCA Data Points</h3>
                    <textarea id="data-points" class="data-points-input">1,2
2,3
3,1
4,5
5,4</textarea>
                    <div class="coordinate-inputs">
                        <div class="coordinate-input">
                            <label for="pca-components">Components to show</label>
                            <input type="number" id="pca-components" value="2" min="1" max="3">
                        </div>
                    </div>
                </div>
                
                <h2 class="section-title">Select Operation</h2>
                <div class="operations-grid">
                    <button class="operation-btn" data-operation="3dAddition">3D Addition/Subtraction</button>
                    <button class="operation-btn" data-operation="reflection">Vector Reflection</button>
                    <button class="operation-btn" data-operation="barycentric">Barycentric Coordinates</button>
                    <button class="operation-btn" data-operation="decomposition">Vector Decomposition</button>
                    <button class="operation-btn" data-operation="gramSchmidt">Gram-Schmidt</button>
                    <button class="operation-btn" data-operation="rotation">Vector Rotation</button>
                    <button class="operation-btn" data-operation="shear">Shear Transformation</button>
                    <button class="operation-btn" data-operation="homogeneous">Homogeneous Coordinates</button>
                    <button class="operation-btn" data-operation="rayIntersection">Ray-Plane Intersection</button>
                    <button class="operation-btn" data-operation="normalVector">Normal Vector</button>
                    <!-- New ultra features -->
                    <button class="operation-btn" data-operation="physicsSandbox">Physics Sandbox</button>
                    <button class="operation-btn" data-operation="quaternionRotation">Quaternion Rotation</button>
                    <button class="operation-btn" data-operation="eigenDecomposition">Eigen Decomposition</button>
                    <button class="operation-btn" data-operation="matrixTransformation">Matrix Transformation</button>
                    <button class="operation-btn" data-operation="vectorField">Vector Field</button>
                    <button class="operation-btn" data-operation="advancedCurves">Advanced Curves</button>
                </div>
                
                <button id="calculate-btn" style="width: 100%; padding: 15px; background: var(--accent); color: white; border: none; border-radius: 8px; font-size: 1.1rem; cursor: pointer; margin-top: 20px;">
                    Calculate & Visualize
                </button>
            </div>
            
            <div class="visualization-section">
                <h2 class="section-title">Visualization</h2>
                
                <div class="visualization-area">
                    <div class="canvas-container">
                        <canvas id="vectorCanvas"></canvas>
                    </div>
                    <div class="canvas-controls">
                        <button id="rotate-x" class="control-btn">Rotate X</button>
                        <button id="rotate-y" class="control-btn">Rotate Y</button>
                        <button id="rotate-z" class="control-btn">Rotate Z</button>
                        <button id="reset-view" class="control-btn">Reset View</button>
                    </div>
                </div>
                
                <div class="result-display">
                    <div class="result-title">Result:</div>
                    <div class="result-value" id="result-value">Select an operation and click calculate</div>
                    
                    <div class="vector-representation">
                        <span class="vector" id="vector-a">A = (3, 4, 2)</span>
                        <span class="operation-symbol" id="operation-symbol">+</span>
                        <span class="vector" id="vector-b">B = (1, -2, 3)</span>
                        <span class="operation-symbol">=</span>
                        <span class="vector" id="vector-result">Result</span>
                    </div>
                    
                    <div class="steps-container" id="steps-container">
                        <!-- Steps will be generated here -->
                    </div>
                </div>
                
                <div class="operation-info">
                    <h4>About this operation:</h4>
                    <p id="operation-description">Select an operation to see its description here.</p>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Advanced Vector Operations Visualizer • Created with HTML, CSS, and JavaScript</p>
        </div>
    </div>

    <script>
        // DOM elements
        const operationButtons = document.querySelectorAll('.operation-btn');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultValue = document.getElementById('result-value');
        const stepsContainer = document.getElementById('steps-container');
        const operationDescription = document.getElementById('operation-description');
        const vectorAElement = document.getElementById('vector-a');
        const vectorBElement = document.getElementById('vector-b');
        const operationSymbol = document.getElementById('operation-symbol');
        const vectorResult = document.getElementById('vector-result');
        const toggle3DBtn = document.getElementById('toggle-3d');
        
        // Additional input sections
        const thirdVectorInput = document.getElementById('third-vector-input');
        const axisInput = document.getElementById('axis-input');
        const pointInput = document.getElementById('point-input');
        const angleInput = document.getElementById('angle-input');
        const shearInput = document.getElementById('shear-input');
        const physicsInput = document.getElementById('physics-input');
        const quaternionInput = document.getElementById('quaternion-input');
        const matrixInput = document.getElementById('matrix-input');
        const transformMatrixInput = document.getElementById('transform-matrix-input');
        const vectorFieldInput = document.getElementById('vector-field-input');
        const curveInput = document.getElementById('curve-input');
        const pcaInput = document.getElementById('pca-input');
        // AI Features Variables
let operationHistory = [];
let aiExplanationsEnabled = false;

// DOM Elements for AI Features
const aiSuggestionsList = document.getElementById('ai-suggestions-list');
const getSuggestionsBtn = document.getElementById('get-suggestions');
const nlCommandInput = document.getElementById('nl-command');
const executeCommandBtn = document.getElementById('execute-command');
const voiceCommandBtn = document.getElementById('voice-command');
const clearCommandBtn = document.getElementById('clear-command');
const commandFeedback = document.getElementById('command-feedback');
const aiExplanationsToggle = document.getElementById('ai-explanations-toggle');
const aiExplanationBox = document.getElementById('ai-explanation');
// Event Listeners for AI Features
getSuggestionsBtn.addEventListener('click', generateAISuggestions);
executeCommandBtn.addEventListener('click', executeNaturalLanguageCommand);
voiceCommandBtn.addEventListener('click', startVoiceRecognition);
clearCommandBtn.addEventListener('click', clearCommand);
aiExplanationsToggle.addEventListener('change', toggleAIExplanations);
        // Canvas setup
        const canvas = document.getElementById('vectorCanvas');
        const ctx = canvas.getContext('2d');
        
        // 3D visualization variables
        let is3DView = false;
        let rotationX = 0;
        let rotationY = 0;
        let rotationZ = 0;
        
        // Physics simulation variables
        let simulationRunning = false;
        let animationId = null;
        let physicsObjects = [];
        
        // Set canvas size to match container
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // 3D Vector class
        class Vector3D {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            
            // Vector operations
            add(v) {
                return new Vector3D(this.x + v.x, this.y + v.y, this.z + v.z);
            }
            
            subtract(v) {
                return new Vector3D(this.x - v.x, this.y - v.y, this.z - v.z);
            }
            
            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }
            
            cross(v) {
                return new Vector3D(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }
            
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector3D(0, 0, 0);
                return new Vector3D(this.x / mag, this.y / mag, this.z / mag);
            }
            
            scale(scalar) {
                return new Vector3D(this.x * scalar, this.y * scalar, this.z * scalar);
            }
            
            angleBetween(v) {
                const dotProduct = this.dot(v);
                const magProduct = this.magnitude() * v.magnitude();
                if (magProduct === 0) return 0;
                return Math.acos(dotProduct / magProduct) * (180 / Math.PI);
            }
            
            projectOnto(v) {
                const scalar = this.dot(v) / v.dot(v);
                return v.scale(scalar);
            }
            
            distanceTo(v) {
                return this.subtract(v).magnitude();
            }
            
            // Reflection over a plane with normal n
            reflect(n) {
                const nNormalized = n.normalize();
                const dot = this.dot(nNormalized);
                return this.subtract(nNormalized.scale(2 * dot));
            }
            
            // Rotate around an axis by angle (degrees)
            rotate(axis, angle) {
                const rad = angle * Math.PI / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                const u = axis.normalize();
                
                const x = this.x * (cos + u.x*u.x*(1-cos)) +
                         this.y * (u.x*u.y*(1-cos) - u.z*sin) +
                         this.z * (u.x*u.z*(1-cos) + u.y*sin);
                         
                const y = this.x * (u.y*u.x*(1-cos) + u.z*sin) +
                         this.y * (cos + u.y*u.y*(1-cos)) +
                         this.z * (u.y*u.z*(1-cos) - u.x*sin);
                         
                const z = this.x * (u.z*u.x*(1-cos) - u.y*sin) +
                         this.y * (u.z*u.y*(1-cos) + u.x*sin) +
                         this.z * (cos + u.z*u.z*(1-cos));
                         
                return new Vector3D(x, y, z);
            }
            
            // Convert to homogeneous coordinates
            toHomogeneous(w = 1) {
                return new Vector4D(this.x, this.y, this.z, w);
            }
            
            // Apply shear transformation
            shear(sx, sy) {
                return new Vector3D(
                    this.x + sx * this.y,
                    this.y + sy * this.x,
                    this.z
                );
            }
            
            // Convert to 2D point for visualization (with perspective)
            to2D(centerX, centerY, scale, perspective = 1000) {
                // Apply 3D rotations
                let x = this.x;
                let y = this.y;
                let z = this.z;
                
                // Rotate around X axis
                let y1 = y * Math.cos(rotationX) - z * Math.sin(rotationX);
                let z1 = y * Math.sin(rotationX) + z * Math.cos(rotationX);
                y = y1;
                z = z1;
                
                // Rotate around Y axis
                let x1 = x * Math.cos(rotationY) + z * Math.sin(rotationY);
                z1 = -x * Math.sin(rotationY) + z * Math.cos(rotationY);
                x = x1;
                z = z1;
                
                // Rotate around Z axis
                x1 = x * Math.cos(rotationZ) - y * Math.sin(rotationZ);
                y1 = x * Math.sin(rotationZ) + y * Math.cos(rotationZ);
                x = x1;
                y = y1;
                
                // Apply perspective projection
                const factor = perspective / (perspective + z);
                x = x * factor;
                y = y * factor;
                
                return {
                    x: centerX + x * scale,
                    y: centerY - y * scale // Invert Y for canvas coordinates
                };
            }
            
            // Apply 4x4 matrix transformation
            transformMatrix(matrix) {
                const x = this.x * matrix[0] + this.y * matrix[4] + this.z * matrix[8] + matrix[12];
                const y = this.x * matrix[1] + this.y * matrix[5] + this.z * matrix[9] + matrix[13];
                const z = this.x * matrix[2] + this.y * matrix[6] + this.z * matrix[10] + matrix[14];
                const w = this.x * matrix[3] + this.y * matrix[7] + this.z * matrix[11] + matrix[15];
                
                if (w !== 0) {
                    return new Vector3D(x/w, y/w, z/w);
                }
                return new Vector3D(x, y, z);
            }
        }
        
        // 4D Vector class for homogeneous coordinates
        class Vector4D {
            constructor(x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            
            // Convert back to 3D (perspective division)
            to3D() {
                if (this.w === 0) return new Vector3D(this.x, this.y, this.z);
                return new Vector3D(this.x / this.w, this.y / this.w, this.z / this.w);
            }
        }
        
        // Quaternion class for advanced rotations
        class Quaternion {
            constructor(w, x, y, z) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
            }
            
            magnitude() {
                return Math.sqrt(this.w*this.w + this.x*this.x + this.y*this.y + this.z*this.z);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Quaternion(1, 0, 0, 0);
                return new Quaternion(this.w/mag, this.x/mag, this.y/mag, this.z/mag);
            }
            
            conjugate() {
                return new Quaternion(this.w, -this.x, -this.y, -this.z);
            }
            
            multiply(q) {
                return new Quaternion(
                    this.w*q.w - this.x*q.x - this.y*q.y - this.z*q.z,
                    this.w*q.x + this.x*q.w + this.y*q.z - this.z*q.y,
                    this.w*q.y - this.x*q.z + this.y*q.w + this.z*q.x,
                    this.w*q.z + this.x*q.y - this.y*q.x + this.z*q.w
                );
            }
            
            // Rotate a vector by this quaternion
            rotateVector(v) {
                const qVec = new Quaternion(0, v.x, v.y, v.z);
                const result = this.multiply(qVec).multiply(this.conjugate());
                return new Vector3D(result.x, result.y, result.z);
            }
            
            // Spherical linear interpolation
            static slerp(q1, q2, t) {
                let cosHalfTheta = q1.w*q2.w + q1.x*q2.x + q1.y*q2.y + q1.z*q2.z;
                
                if (cosHalfTheta < 0) {
                    q2 = new Quaternion(-q2.w, -q2.x, -q2.y, -q2.z);
                    cosHalfTheta = -cosHalfTheta;
                }
                
                if (Math.abs(cosHalfTheta) >= 1.0) {
                    return q1;
                }
                
                const halfTheta = Math.acos(cosHalfTheta);
                const sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta*cosHalfTheta);
                
                if (Math.abs(sinHalfTheta) < 0.001) {
                    return new Quaternion(
                        q1.w * 0.5 + q2.w * 0.5,
                        q1.x * 0.5 + q2.x * 0.5,
                        q1.y * 0.5 + q2.y * 0.5,
                        q1.z * 0.5 + q2.z * 0.5
                    );
                }
                
                const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
                const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                
                return new Quaternion(
                    q1.w * ratioA + q2.w * ratioB,
                    q1.x * ratioA + q2.x * ratioB,
                    q1.y * ratioA + q2.y * ratioB,
                    q1.z * ratioA + q2.z * ratioB
                );
            }
            
            // Convert to rotation matrix (3x3)
            toRotationMatrix() {
                const xx = this.x * this.x;
                const xy = this.x * this.y;
                const xz = this.x * this.z;
                const xw = this.x * this.w;
                
                const yy = this.y * this.y;
                const yz = this.y * this.z;
                const yw = this.y * this.w;
                
                const zz = this.z * this.z;
                const zw = this.z * this.w;
                
                return [
                    1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw),
                    2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw),
                    2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy)
                ];
            }
        }
        
        // Physics object class
        class PhysicsObject {
            constructor(position, velocity, mass) {
                this.position = position;
                this.velocity = velocity;
                this.acceleration = new Vector3D(0, 0, 0);
                this.mass = mass;
                this.force = new Vector3D(0, 0, 0);
            }
            
            applyForce(force) {
                this.force = this.force.add(force);
            }
            
            update(deltaTime) {
                // F = ma, so a = F/m
                this.acceleration = this.force.scale(1 / this.mass);
                
                // Update velocity and position
                this.velocity = this.velocity.add(this.acceleration.scale(deltaTime));
                this.position = this.position.add(this.velocity.scale(deltaTime));
                
                // Reset force for next frame
                this.force = new Vector3D(0, 0, 0);
            }
        }
        
        // Current vectors and operation
        let vectorA = new Vector3D(3, 4, 2);
        let vectorB = new Vector3D(1, -2, 3);
        let vectorC = new Vector3D(0, 3, -1);
        let pointP = new Vector3D(1.5, 2, 1);
        let axis = new Vector3D(1, 0, 0);
        let angle = 45;
        let shearX = 0.5;
        let shearY = 0;
        let currentOperation = '3dAddition';
        
        // Operation descriptions
        const operationDescriptions = {
            '3dAddition': "3D Vector Addition/Subtraction extends the 2D concept to three dimensions. Vectors are added component-wise, and the result is visualized in a 3D space with a parallelepiped representation for multi-vector sums.",
            'reflection': "Vector Reflection calculates the mirror image of a vector over a specified line or plane. This is useful in optics for simulating light reflection and in computer graphics for environment mapping.",
            'barycentric': "Barycentric Coordinates represent a point inside a triangle as a weighted combination of the triangle's vertices. These coordinates are fundamental in computer graphics for interpolation across triangular meshes.",
            'decomposition': "Vector Decomposition breaks down a vector into components along specified basis vectors. This is essential for changing coordinate systems and understanding vector components in different frames of reference.",
            'gramSchmidt': "Gram-Schmidt Orthogonalization transforms a set of vectors into an orthogonal or orthonormal basis. This process is crucial for QR decomposition and many numerical algorithms.",
            'rotation': "Vector Rotation rotates a vector around a specified axis by a given angle. This operation is fundamental in 3D graphics, robotics, and physics simulations.",
            'shear': "Shear Transformation skews a vector along specified axes, changing its direction while preserving certain properties. Shear transformations are used in computer graphics for distortion effects.",
            'homogeneous': "Homogeneous Coordinates extend 3D vectors with a fourth component (w) to represent points at infinity and simplify perspective transformations. This is the foundation of 3D graphics pipelines.",
            'rayIntersection': "Ray-Plane Intersection calculates where a ray (defined by an origin and direction) intersects a plane. This is a fundamental operation in ray tracing for 3D rendering.",
            'normalVector': "Normal Vector Computation calculates a vector perpendicular to a plane defined by two vectors. Normal vectors are essential for lighting calculations in 3D graphics.",
            'physicsSandbox': "Physics Sandbox introduces mass, velocity, and forces to create a real-time physics simulation. Visualize concepts like momentum, collisions, and orbital mechanics.",
            'quaternionRotation': "Quaternion Rotation provides a gimbal-lock-free method for 3D rotations. Includes spherical linear interpolation (SLERP) for smooth transitions between orientations.",
            'eigenDecomposition': "Eigen Decomposition calculates eigenvectors and eigenvalues of a matrix, showing principal components of data. Fundamental for machine learning and data analysis.",
            'matrixTransformation': "Matrix Transformation allows building custom 4x4 transformation matrices and applying them to 3D objects. Demonstrates the core of 3D graphics pipelines.",
            'vectorField': "Vector Field Visualization creates 2D or 3D vector fields defined by mathematical expressions. Essential for understanding fluid dynamics and electromagnetism.",
            'advancedCurves': "Advanced Curves generates Bézier curves and surfaces using control points. Shows the mathematical foundation of modern CAD and 3D modeling."
        };
        
        // Initialize with first operation selected
        operationButtons[0].classList.add('active');
        operationDescription.textContent = operationDescriptions[currentOperation];
        
        // Event listeners
        operationButtons.forEach(button => {
            button.addEventListener('click', () => {
                operationButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentOperation = button.dataset.operation;
                operationDescription.textContent = operationDescriptions[currentOperation];
                
                // Show/hide additional inputs based on operation
                thirdVectorInput.classList.remove('active');
                axisInput.classList.remove('active');
                pointInput.classList.remove('active');
                angleInput.classList.remove('active');
                shearInput.classList.remove('active');
                physicsInput.classList.remove('active');
                quaternionInput.classList.remove('active');
                matrixInput.classList.remove('active');
                transformMatrixInput.classList.remove('active');
                vectorFieldInput.classList.remove('active');
                curveInput.classList.remove('active');
                pcaInput.classList.remove('active');
                
                switch(currentOperation) {
                    case 'barycentric':
                    case 'gramSchmidt':
                        thirdVectorInput.classList.add('active');
                        break;
                    case 'reflection':
                    case 'rotation':
                    case 'normalVector':
                        axisInput.classList.add('active');
                        break;
                    case 'barycentric':
                        pointInput.classList.add('active');
                        break;
                    case 'rotation':
                        angleInput.classList.add('active');
                        break;
                    case 'shear':
                        shearInput.classList.add('active');
                        break;
                    case 'physicsSandbox':
                        physicsInput.classList.add('active');
                        break;
                    case 'quaternionRotation':
                        quaternionInput.classList.add('active');
                        break;
                    case 'eigenDecomposition':
                        matrixInput.classList.add('active');
                        pcaInput.classList.add('active');
                        break;
                    case 'matrixTransformation':
                        transformMatrixInput.classList.add('active');
                        break;
                    case 'vectorField':
                        vectorFieldInput.classList.add('active');
                        break;
                    case 'advancedCurves':
                        curveInput.classList.add('active');
                        break;
                }
            });
        });
        
        calculateBtn.addEventListener('click', calculateOperation);
        toggle3DBtn.addEventListener('click', toggle3DView);
        
        // Physics simulation controls
        document.getElementById('start-sim').addEventListener('click', startPhysicsSimulation);
        document.getElementById('pause-sim').addEventListener('click', pausePhysicsSimulation);
        document.getElementById('reset-sim').addEventListener('click', resetPhysicsSimulation);
        
        // 3D rotation controls
        document.getElementById('rotate-x').addEventListener('click', () => {
            rotationX += Math.PI / 8;
            calculateOperation();
        });
        
        document.getElementById('rotate-y').addEventListener('click', () => {
            rotationY += Math.PI / 8;
            calculateOperation();
        });
        
        document.getElementById('rotate-z').addEventListener('click', () => {
            rotationZ += Math.PI / 8;
            calculateOperation();
        });
        
        document.getElementById('reset-view').addEventListener('click', () => {
            rotationX = 0;
            rotationY = 0;
            rotationZ = 0;
            calculateOperation();
        });
        
        // Input change handlers
        document.getElementById('a-x').addEventListener('input', updateVectors);
        document.getElementById('a-y').addEventListener('input', updateVectors);
        document.getElementById('a-z').addEventListener('input', updateVectors);
        document.getElementById('b-x').addEventListener('input', updateVectors);
        document.getElementById('b-y').addEventListener('input', updateVectors);
        document.getElementById('b-z').addEventListener('input', updateVectors);
        document.getElementById('c-x').addEventListener('input', updateVectors);
        document.getElementById('c-y').addEventListener('input', updateVectors);
        document.getElementById('c-z').addEventListener('input', updateVectors);
        document.getElementById('p-x').addEventListener('input', updateVectors);
        document.getElementById('p-y').addEventListener('input', updateVectors);
        document.getElementById('p-z').addEventListener('input', updateVectors);
        document.getElementById('axis-x').addEventListener('input', updateVectors);
        document.getElementById('axis-y').addEventListener('input', updateVectors);
        document.getElementById('axis-z').addEventListener('input', updateVectors);
        document.getElementById('angle-value').addEventListener('input', updateVectors);
        document.getElementById('shear-x').addEventListener('input', updateVectors);
        document.getElementById('shear-y').addEventListener('input', updateVectors);
        
        // New input handlers for advanced features
        document.getElementById('mass-value').addEventListener('input', updateVectors);
        document.getElementById('gravity-value').addEventListener('input', updateVectors);
        document.getElementById('spring-constant').addEventListener('input', updateVectors);
        document.getElementById('damping').addEventListener('input', updateVectors);
        document.getElementById('quat-w').addEventListener('input', updateVectors);
        document.getElementById('quat-x').addEventListener('input', updateVectors);
        document.getElementById('quat-y').addEventListener('input', updateVectors);
        document.getElementById('quat-z').addEventListener('input', updateVectors);
        document.getElementById('slerp-factor').addEventListener('input', updateVectors);
        document.getElementById('field-type').addEventListener('change', updateVectors);
        document.getElementById('custom-field').addEventListener('input', updateVectors);
        document.getElementById('field-resolution').addEventListener('input', updateVectors);
        document.getElementById('curve-segments').addEventListener('input', updateVectors);
        document.getElementById('pca-components').addEventListener('input', updateVectors);
        document.getElementById('data-points').addEventListener('input', updateVectors);
        
        // Matrix input handlers
        for (let i = 1; i <= 3; i++) {
            for (let j = 1; j <= 3; j++) {
                document.getElementById(`m${i}${j}`).addEventListener('input', updateVectors);
            }
        }
        
        for (let i = 1; i <= 4; i++) {
            for (let j = 1; j <= 4; j++) {
                document.getElementById(`t${i}${j}`).addEventListener('input', updateVectors);
            }
        }
        
        // Curve control point handlers
        for (let i = 1; i <= 4; i++) {
            document.getElementById(`cp${i}-x`).addEventListener('input', updateVectors);
            document.getElementById(`cp${i}-y`).addEventListener('input', updateVectors);
        }
        
        function updateVectors() {
            vectorA = new Vector3D(
                parseFloat(document.getElementById('a-x').value) || 0,
                parseFloat(document.getElementById('a-y').value) || 0,
                parseFloat(document.getElementById('a-z').value) || 0
            );
            
            vectorB = new Vector3D(
                parseFloat(document.getElementById('b-x').value) || 0,
                parseFloat(document.getElementById('b-y').value) || 0,
                parseFloat(document.getElementById('b-z').value) || 0
            );
            
            vectorC = new Vector3D(
                parseFloat(document.getElementById('c-x').value) || 0,
                parseFloat(document.getElementById('c-y').value) || 0,
                parseFloat(document.getElementById('c-z').value) || 0
            );
            
            pointP = new Vector3D(
                parseFloat(document.getElementById('p-x').value) || 0,
                parseFloat(document.getElementById('p-y').value) || 0,
                parseFloat(document.getElementById('p-z').value) || 0
            );
            
            axis = new Vector3D(
                parseFloat(document.getElementById('axis-x').value) || 0,
                parseFloat(document.getElementById('axis-y').value) || 0,
                parseFloat(document.getElementById('axis-z').value) || 0
            );
            
            angle = parseFloat(document.getElementById('angle-value').value) || 0;
            shearX = parseFloat(document.getElementById('shear-x').value) || 0;
            shearY = parseFloat(document.getElementById('shear-y').value) || 0;
            
            // Update vector representations
            vectorAElement.textContent = `A = (${vectorA.x}, ${vectorA.y}, ${vectorA.z})`;
            vectorBElement.textContent = `B = (${vectorB.x}, ${vectorB.y}, ${vectorB.z})`;
            
            calculateOperation();
        }
        
        function toggle3DView() {
            is3DView = !is3DView;
            toggle3DBtn.textContent = is3DView ? 'Toggle 2D/3D View (3D)' : 'Toggle 2D/3D View (2D)';
            calculateOperation();
        }
        
        // Physics simulation functions
        function startPhysicsSimulation() {
            if (!simulationRunning) {
                simulationRunning = true;
                physicsObjects = [
                    new PhysicsObject(
                        new Vector3D(-2, 2, 0),
                        new Vector3D(1, 0, 0),
                        parseFloat(document.getElementById('mass-value').value) || 1
                    )
                ];
                physicsLoop();
            }
        }
        
        function pausePhysicsSimulation() {
            simulationRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetPhysicsSimulation() {
            pausePhysicsSimulation();
            calculateOperation();
        }
        
        function physicsLoop() {
            if (!simulationRunning) return;
            
            const deltaTime = 0.016; // ~60 FPS
            const gravity = parseFloat(document.getElementById('gravity-value').value) || 9.8;
            const springConstant = parseFloat(document.getElementById('spring-constant').value) || 0.5;
            const damping = parseFloat(document.getElementById('damping').value) || 0.1;
            
            physicsObjects.forEach(obj => {
                // Apply gravity
                obj.applyForce(new Vector3D(0, -gravity * obj.mass, 0));
                
                // Apply spring force toward origin
                const springForce = obj.position.scale(-springConstant);
                obj.applyForce(springForce);
                
                // Apply damping
                const dampingForce = obj.velocity.scale(-damping);
                obj.applyForce(dampingForce);
                
                obj.update(deltaTime);
            });
            
            calculateOperation();
            animationId = requestAnimationFrame(physicsLoop);
        }
        
        // Calculate the selected operation
        function calculateOperation() {
            let result;
            let steps = [];
            
            // Update operation symbol
            switch(currentOperation) {
                case '3dAddition': operationSymbol.textContent = '+/-'; break;
                case 'reflection': operationSymbol.textContent = 'R'; break;
                case 'barycentric': operationSymbol.textContent = 'αβγ'; break;
                case 'decomposition': operationSymbol.textContent = '→'; break;
                case 'gramSchmidt': operationSymbol.textContent = '⟂'; break;
                case 'rotation': operationSymbol.textContent = '↻'; break;
                case 'shear': operationSymbol.textContent = '⤡'; break;
                case 'homogeneous': operationSymbol.textContent = 'H'; break;
                case 'rayIntersection': operationSymbol.textContent = '∩'; break;
                case 'normalVector': operationSymbol.textContent = '⊥'; break;
                case 'physicsSandbox': operationSymbol.textContent = '⚛'; break;
                case 'quaternionRotation': operationSymbol.textContent = 'Q'; break;
                case 'eigenDecomposition': operationSymbol.textContent = 'λ'; break;
                case 'matrixTransformation': operationSymbol.textContent = 'M'; break;
                case 'vectorField': operationSymbol.textContent = '⇄'; break;
                case 'advancedCurves': operationSymbol.textContent = '⌒'; break;
            }
               // Track operation for AI suggestions
    addToOperationHistory(currentOperation, {
        a: vectorA,
        b: vectorB,
        c: vectorC
    });
    
    // Generate AI explanation if enabled
    if (aiExplanationsEnabled) {
        generateAIExplanation();
    }
 
            // Calculate based on selected operation
            switch(currentOperation) {
                case '3dAddition':
    const sum = vectorA.add(vectorB);
    const difference = vectorA.subtract(vectorB);
    steps.push(`Add corresponding components: (${vectorA.x} + ${vectorB.x}, ${vectorA.y} + ${vectorB.y}, ${vectorA.z} + ${vectorB.z})`);
    steps.push(`Sum Result: (${sum.x}, ${sum.y}, ${sum.z})`);
    steps.push(`Subtract corresponding components: (${vectorA.x} - ${vectorB.x}, ${vectorA.y} - ${vectorB.y}, ${vectorA.z} - ${vectorB.z})`);
    steps.push(`Difference Result: (${difference.x}, ${difference.y}, ${difference.z})`);
    resultValue.textContent = `Sum: (${sum.x.toFixed(2)}, ${sum.y.toFixed(2)}, ${sum.z.toFixed(2)}) | Difference: (${difference.x.toFixed(2)}, ${difference.y.toFixed(2)}, ${difference.z.toFixed(2)})`;
    vectorResult.textContent = `Sum = (${sum.x.toFixed(2)}, ${sum.y.toFixed(2)}, ${sum.z.toFixed(2)}) | Diff = (${difference.x.toFixed(2)}, ${difference.y.toFixed(2)}, ${difference.z.toFixed(2)})`;
    // Pass both results to visualization
    visualizeOperation({ sum, difference }, steps);
    break;
                case 'reflection':
                    const normal = axis.normalize();
                    const dotProduct = vectorA.dot(normal);
                    result = vectorA.subtract(normal.scale(2 * dotProduct));
                    steps.push(`Normalize reflection axis: (${axis.x}, ${axis.y}, ${axis.z}) → (${normal.x.toFixed(2)}, ${normal.y.toFixed(2)}, ${normal.z.toFixed(2)})`);
                    steps.push(`Calculate dot product: A · n = ${vectorA.x}*${normal.x} + ${vectorA.y}*${normal.y} + ${vectorA.z}*${normal.z} = ${dotProduct.toFixed(2)}`);
                    steps.push(`Reflection formula: A - 2(A·n)n = A - 2*${dotProduct.toFixed(2)}*n`);
                    steps.push(`Result: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                    resultValue.textContent = `Reflected Vector: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    vectorResult.textContent = `Reflected = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    break;
                    
                case 'barycentric':
                    // For simplicity, we'll use a 2D approach for barycentric coordinates
                    // In a real implementation, this would need to handle the 3D case properly
                    const areaABC = vectorB.subtract(vectorA).cross(vectorC.subtract(vectorA)).magnitude();
                    const areaPBC = vectorB.subtract(pointP).cross(vectorC.subtract(pointP)).magnitude();
                    const areaAPC = vectorA.subtract(pointP).cross(vectorC.subtract(vectorA)).magnitude();
                    const areaABP = vectorA.subtract(pointP).cross(vectorB.subtract(pointP)).magnitude();
                    
                    const alpha = areaPBC / areaABC;
                    const beta = areaAPC / areaABC;
                    const gamma = areaABP / areaABC;
                    
                    steps.push(`Calculate area of triangle ABC: ${areaABC.toFixed(2)}`);
                    steps.push(`Calculate area of triangle PBC: ${areaPBC.toFixed(2)}`);
                    steps.push(`Calculate area of triangle APC: ${areaAPC.toFixed(2)}`);
                    steps.push(`Calculate area of triangle ABP: ${areaABP.toFixed(2)}`);
                    steps.push(`Barycentric coordinates: α = ${alpha.toFixed(2)}, β = ${beta.toFixed(2)}, γ = ${gamma.toFixed(2)}`);
                    
                    resultValue.textContent = `Barycentric Coordinates: α=${alpha.toFixed(2)}, β=${beta.toFixed(2)}, γ=${gamma.toFixed(2)}`;
                    vectorResult.textContent = `P = ${alpha.toFixed(2)}A + ${beta.toFixed(2)}B + ${gamma.toFixed(2)}C`;
                    break;
                    
                case 'decomposition':
                    const basisX = new Vector3D(1, 0, 0);
                    const basisY = new Vector3D(0, 1, 0);
                    const basisZ = new Vector3D(0, 0, 1);
                    
                    const projX = vectorA.projectOnto(basisX);
                    const projY = vectorA.projectOnto(basisY);
                    const projZ = vectorA.projectOnto(basisZ);
                    
                    steps.push(`Project A onto X-axis: (${vectorA.x}, 0, 0)`);
                    steps.push(`Project A onto Y-axis: (0, ${vectorA.y}, 0)`);
                    steps.push(`Project A onto Z-axis: (0, 0, ${vectorA.z})`);
                    steps.push(`Sum of projections equals original vector`);
                    
                    resultValue.textContent = `Decomposition: X=${vectorA.x.toFixed(2)}, Y=${vectorA.y.toFixed(2)}, Z=${vectorA.z.toFixed(2)}`;
                    vectorResult.textContent = `A = (${vectorA.x.toFixed(2)}, 0, 0) + (0, ${vectorA.y.toFixed(2)}, 0) + (0, 0, ${vectorA.z.toFixed(2)})`;
                    break;
                    
                case 'gramSchmidt':
                    // For simplicity, we'll demonstrate with two vectors
                    const u1 = vectorA.normalize();
                    const proj = vectorB.projectOnto(u1);
                    const u2 = vectorB.subtract(proj).normalize();
                    
                    steps.push(`Step 1: u₁ = A / |A| = (${u1.x.toFixed(2)}, ${u1.y.toFixed(2)}, ${u1.z.toFixed(2)})`);
                    steps.push(`Step 2: Project B onto u₁: (${proj.x.toFixed(2)}, ${proj.y.toFixed(2)}, ${proj.z.toFixed(2)})`);
                    steps.push(`Step 3: Subtract projection: B - proj = (${u2.x.toFixed(2)}, ${u2.y.toFixed(2)}, ${u2.z.toFixed(2)})`);
                    steps.push(`Step 4: Normalize: u₂ = (${u2.x.toFixed(2)}, ${u2.y.toFixed(2)}, ${u2.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Orthonormal Basis: u₁=(${u1.x.toFixed(2)}, ${u1.y.toFixed(2)}, ${u1.z.toFixed(2)}), u₂=(${u2.x.toFixed(2)}, ${u2.y.toFixed(2)}, ${u2.z.toFixed(2)})`;
                    vectorResult.textContent = `Orthonormal basis created`;
                    break;
                    
                case 'rotation':
                    result = vectorA.rotate(axis, angle);
                    steps.push(`Rotation axis: (${axis.x}, ${axis.y}, ${axis.z})`);
                    steps.push(`Rotation angle: ${angle}°`);
                    steps.push(`Apply rotation matrix`);
                    steps.push(`Result: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Rotated Vector: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    vectorResult.textContent = `Rotated = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    break;
                    
                case 'shear':
                    result = vectorA.shear(shearX, shearY);
                    steps.push(`Shear factors: X=${shearX}, Y=${shearY}`);
                    steps.push(`Apply shear transformation: x' = x + ${shearX}*y, y' = y + ${shearY}*x`);
                    steps.push(`Result: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Sheared Vector: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    vectorResult.textContent = `Sheared = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    break;
                    
                case 'homogeneous':
                    const homogeneous = vectorA.toHomogeneous(1);
                    const perspective = vectorA.toHomogeneous(0.5).to3D();
                    
                    steps.push(`Homogeneous coordinates: (${vectorA.x}, ${vectorA.y}, ${vectorA.z}, 1)`);
                    steps.push(`Perspective division with w=0.5: (${vectorA.x}/0.5, ${vectorA.y}/0.5, ${vectorA.z}/0.5)`);
                    steps.push(`Result: (${perspective.x.toFixed(2)}, ${perspective.y.toFixed(2)}, ${perspective.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Homogeneous: (${vectorA.x}, ${vectorA.y}, ${vectorA.z}, 1) → Perspective: (${perspective.x.toFixed(2)}, ${perspective.y.toFixed(2)}, ${perspective.z.toFixed(2)})`;
                    vectorResult.textContent = `Perspective = (${perspective.x.toFixed(2)}, ${perspective.y.toFixed(2)}, ${perspective.z.toFixed(2)})`;
                    break;
                    
                case 'rayIntersection':
                    // Ray from origin with direction vectorA
                    // Plane defined by point vectorB and normal vectorC
                    const rayOrigin = new Vector3D(0, 0, 0);
                    const rayDirection = vectorA.normalize();
                    const planePoint = vectorB;
                    const planeNormal = vectorC.normalize();
                    
                    const denominator = rayDirection.dot(planeNormal);
                    
                    if (Math.abs(denominator) > 0.0001) {
                        const t = planePoint.subtract(rayOrigin).dot(planeNormal) / denominator;
                        result = rayOrigin.add(rayDirection.scale(t));
                        
                        steps.push(`Ray origin: (0, 0, 0)`);
                        steps.push(`Ray direction: (${rayDirection.x.toFixed(2)}, ${rayDirection.y.toFixed(2)}, ${rayDirection.z.toFixed(2)})`);
                        steps.push(`Plane point: (${planePoint.x}, ${planePoint.y}, ${planePoint.z})`);
                        steps.push(`Plane normal: (${planeNormal.x.toFixed(2)}, ${planeNormal.y.toFixed(2)}, ${planeNormal.z.toFixed(2)})`);
                        steps.push(`Calculate intersection parameter t = ${t.toFixed(2)}`);
                        steps.push(`Intersection point: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                        
                        resultValue.textContent = `Intersection Point: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)}) at distance ${t.toFixed(2)}`;
                        vectorResult.textContent = `Intersection = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    } else {
                        steps.push(`Ray is parallel to the plane, no intersection`);
                        resultValue.textContent = `No intersection (ray parallel to plane)`;
                        vectorResult.textContent = `No intersection`;
                    }
                    break;
                    
                case 'normalVector':
                    result = vectorA.cross(vectorB);
                    steps.push(`Calculate cross product: A × B`);
                    steps.push(`x = A_y*B_z - A_z*B_y = ${vectorA.y}*${vectorB.z} - ${vectorA.z}*${vectorB.y} = ${result.x}`);
                    steps.push(`y = A_z*B_x - A_x*B_z = ${vectorA.z}*${vectorB.x} - ${vectorA.x}*${vectorB.z} = ${result.y}`);
                    steps.push(`z = A_x*B_y - A_y*B_x = ${vectorA.x}*${vectorB.y} - ${vectorA.y}*${vectorB.x} = ${result.z}`);
                    steps.push(`Normal vector: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Normal Vector: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    vectorResult.textContent = `Normal = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    break;
                    
                case 'physicsSandbox':
                    if (simulationRunning) {
                        resultValue.textContent = `Physics Simulation Running - Mass: ${physicsObjects[0].mass.toFixed(2)}`;
                        vectorResult.textContent = `Position: (${physicsObjects[0].position.x.toFixed(2)}, ${physicsObjects[0].position.y.toFixed(2)}, ${physicsObjects[0].position.z.toFixed(2)})`;
                    } else {
                        resultValue.textContent = 'Click "Start Simulation" to begin physics sandbox';
                        vectorResult.textContent = 'Physics Sandbox';
                    }
                    steps.push('Physics sandbox demonstrates real-time dynamics simulation');
                    steps.push('Forces applied: Gravity, Spring force toward origin, Damping');
                    steps.push('Equations: F = ma, Spring force = -kx, Damping force = -cv');
                    break;
                    
                case 'quaternionRotation':
                    const quatW = parseFloat(document.getElementById('quat-w').value) || 1;
                    const quatX = parseFloat(document.getElementById('quat-x').value) || 0;
                    const quatY = parseFloat(document.getElementById('quat-y').value) || 0;
                    const quatZ = parseFloat(document.getElementById('quat-z').value) || 0;
                    const slerpFactor = parseFloat(document.getElementById('slerp-factor').value) || 0.5;
                    
                    const quaternion = new Quaternion(quatW, quatX, quatY, quatZ).normalize();
                    const identityQuat = new Quaternion(1, 0, 0, 0);
                    const interpolatedQuat = Quaternion.slerp(identityQuat, quaternion, slerpFactor);
                    
                    result = interpolatedQuat.rotateVector(vectorA);
                    
                    steps.push(`Quaternion: (${quaternion.w.toFixed(2)}, ${quaternion.x.toFixed(2)}, ${quaternion.y.toFixed(2)}, ${quaternion.z.toFixed(2)})`);
                    steps.push(`SLERP factor: ${slerpFactor}`);
                    steps.push(`Rotated vector using quaternion rotation`);
                    steps.push(`Result: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Quaternion Rotation: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    vectorResult.textContent = `Rotated = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    break;
                    
                case 'eigenDecomposition':
                    // Simple 2x2 eigen decomposition for demonstration
                    const m11 = parseFloat(document.getElementById('m11').value) || 2;
                    const m12 = parseFloat(document.getElementById('m12').value) || 1;
                    const m21 = parseFloat(document.getElementById('m21').value) || 1;
                    const m22 = parseFloat(document.getElementById('m22').value) || 3;
                    
                    // Calculate eigenvalues for 2x2 matrix
                    const trace = m11 + m22;
                    const determinant = m11 * m22 - m12 * m21;
                    const discriminant = trace * trace - 4 * determinant;
                    
                    if (discriminant >= 0) {
                        const eigenvalue1 = (trace + Math.sqrt(discriminant)) / 2;
                        const eigenvalue2 = (trace - Math.sqrt(discriminant)) / 2;
                        
                        steps.push(`Matrix: [[${m11}, ${m12}], [${m21}, ${m22}]]`);
                        steps.push(`Trace: ${trace}`);
                        steps.push(`Determinant: ${determinant}`);
                        steps.push(`Eigenvalues: λ₁ = ${eigenvalue1.toFixed(2)}, λ₂ = ${eigenvalue2.toFixed(2)}`);
                        
                        resultValue.textContent = `Eigenvalues: λ₁ = ${eigenvalue1.toFixed(2)}, λ₂ = ${eigenvalue2.toFixed(2)}`;
                        vectorResult.textContent = `Eigen decomposition complete`;
                    } else {
                        steps.push('Matrix has complex eigenvalues (not visualized)');
                        resultValue.textContent = 'Complex eigenvalues detected';
                        vectorResult.textContent = 'Use real symmetric matrix for visualization';
                    }
                    break;
                    
                case 'matrixTransformation':
                    // Build 4x4 transformation matrix
                    const transformationMatrix = [];
                    for (let i = 1; i <= 4; i++) {
                        for (let j = 1; j <= 4; j++) {
                            transformationMatrix.push(parseFloat(document.getElementById(`t${i}${j}`).value) || 0);
                        }
                    }
                    
                    result = vectorA.transformMatrix(transformationMatrix);
                    
                    steps.push(`Applied 4x4 transformation matrix to vector A`);
                    steps.push(`Result: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`);
                    
                    resultValue.textContent = `Transformed Vector: (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    vectorResult.textContent = `Transformed = (${result.x.toFixed(2)}, ${result.y.toFixed(2)}, ${result.z.toFixed(2)})`;
                    break;
                    
                case 'vectorField':
                    resultValue.textContent = 'Vector Field Visualization';
                    vectorResult.textContent = 'Field shown in visualization area';
                    steps.push('Vector field visualization active');
                    steps.push('Arrows show direction and magnitude of field vectors');
                    break;
                    
                case 'advancedCurves':
                    resultValue.textContent = 'Bézier Curve Visualization';
                    vectorResult.textContent = 'Curve shown with control points';
                    steps.push('Bézier curve generated from control points');
                    steps.push('Curve demonstrates parametric polynomial interpolation');
                    break;
            }
            
            // Display steps
            stepsContainer.innerHTML = '';
            steps.forEach((step, index) => {
                const stepElement = document.createElement('div');
                stepElement.className = 'step';
                stepElement.innerHTML = `<span class="step-number">${index + 1}</span> ${step}`;
                stepsContainer.appendChild(stepElement);
            });
            
            // Visualize the result
            visualizeOperation(result, steps);
        }
        
        // Visualize the vectors and operation
        function visualizeOperation(result, steps) {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Center of canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = Math.min(canvas.width, canvas.height) / 8;
            
            // Draw coordinate system
            drawCoordinateSystem(centerX, centerY, scale);
            
            // Draw vectors based on operation
            switch(currentOperation) {
case '3dAddition':
    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
    drawVector(vectorB, centerX, centerY, scale, '#6b8cbc', 'B');
    drawVector(result.sum, centerX, centerY, scale, '#ff6b6b', 'A+B');
    drawVector(result.difference, centerX, centerY, scale, '#20c997', 'A-B');
    drawParallelogram(vectorA, vectorB, centerX, centerY, scale); // For sum
    // Optionally draw parallelogram for difference
    drawParallelogram(vectorA, vectorB.scale(-1), centerX, centerY, scale, true); // For difference
    break;
                    
                case 'reflection':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(axis, centerX, centerY, scale, '#6f42c1', 'Axis');
                    drawVector(result, centerX, centerY, scale, '#ff6b6b', 'Reflected');
                    drawReflection(vectorA, axis, result, centerX, centerY, scale);
                    break;
                    
                case 'barycentric':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(vectorB, centerX, centerY, scale, '#6b8cbc', 'B');
                    drawVector(vectorC, centerX, centerY, scale, '#6f42c1', 'C');
                    drawPoint(pointP, centerX, centerY, scale, '#ff6b6b', 'P');
                    drawTriangle(vectorA, vectorB, vectorC, centerX, centerY, scale);
                    break;
                    
                case 'decomposition':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVectorComponents(vectorA, centerX, centerY, scale);
                    break;
                    
                case 'gramSchmidt':
                    const u1 = vectorA.normalize();
                    const proj = vectorB.projectOnto(u1);
                    const u2 = vectorB.subtract(proj).normalize();
                    
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(vectorB, centerX, centerY, scale, '#6b8cbc', 'B');
                    drawVector(u1, centerX, centerY, scale, '#20c997', 'u₁');
                    drawVector(u2, centerX, centerY, scale, '#ff6b6b', 'u₂');
                    drawProjection(vectorB, u1, centerX, centerY, scale);
                    break;
                    
                case 'rotation':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(axis, centerX, centerY, scale, '#6f42c1', 'Axis');
                    drawVector(result, centerX, centerY, scale, '#ff6b6b', 'Rotated');
                    drawRotationArc(vectorA, result, axis, centerX, centerY, scale);
                    break;
                    
                case 'shear':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(result, centerX, centerY, scale, '#ff6b6b', 'Sheared');
                    drawShearedShape(vectorA, result, centerX, centerY, scale);
                    break;
                    
                case 'homogeneous':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    const perspective = vectorA.toHomogeneous(0.5).to3D();
                    drawVector(perspective, centerX, centerY, scale, '#ff6b6b', 'Perspective');
                    drawVanishingPoint(centerX, centerY, scale);
                    break;
                    
                case 'rayIntersection':
                    const rayOrigin = new Vector3D(0, 0, 0);
                    const rayDirection = vectorA.normalize();
                    const planePoint = vectorB;
                    const planeNormal = vectorC.normalize();
                    
                    const denominator = rayDirection.dot(planeNormal);
                    
                    if (Math.abs(denominator) > 0.0001) {
                        const t = planePoint.subtract(rayOrigin).dot(planeNormal) / denominator;
                        const intersection = rayOrigin.add(rayDirection.scale(t));
                        
                        drawRay(rayOrigin, rayDirection, centerX, centerY, scale);
                        drawPlane(planePoint, planeNormal, centerX, centerY, scale);
                        drawPoint(intersection, centerX, centerY, scale, '#ff6b6b', 'Intersection');
                    }
                    break;
                    
                case 'normalVector':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(vectorB, centerX, centerY, scale, '#6b8cbc', 'B');
                    drawVector(result, centerX, centerY, scale, '#ff6b6b', 'Normal');
                    drawPlaneFromVectors(vectorA, vectorB, centerX, centerY, scale);
                    break;
                    
                case 'physicsSandbox':
                    if (simulationRunning) {
                        physicsObjects.forEach((obj, index) => {
                            drawPoint(obj.position, centerX, centerY, scale, '#ff6b6b', `Obj${index+1}`);
                            drawVector(obj.velocity, obj.position.x, obj.position.y, scale, '#20c997', 'V');
                        });
                    } else {
                        drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                        drawVector(vectorB, centerX, centerY, scale, '#6b8cbc', 'B');
                    }
                    break;
                    
                case 'quaternionRotation':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(result, centerX, centerY, scale, '#ff6b6b', 'Rotated');
                    drawRotationArc(vectorA, result, new Vector3D(0, 1, 0), centerX, centerY, scale);
                    break;
                    
                case 'eigenDecomposition':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(vectorB, centerX, centerY, scale, '#6b8cbc', 'B');
                    // Simple eigenvector visualization
                    drawVector(new Vector3D(2, 1, 0), centerX, centerY, scale, '#20c997', 'v₁');
                    drawVector(new Vector3D(-1, 2, 0), centerX, centerY, scale, '#ff6b6b', 'v₂');
                    break;
                    
                case 'matrixTransformation':
                    drawVector(vectorA, centerX, centerY, scale, '#4a6fa5', 'A');
                    drawVector(result, centerX, centerY, scale, '#ff6b6b', 'Transformed');
                    break;
                    
                case 'vectorField':
                    drawVectorField(centerX, centerY, scale);
                    break;
                    
                case 'advancedCurves':
                    drawBezierCurve(centerX, centerY, scale);
                    break;
            }
        }
        
        // New drawing functions for advanced features
        function drawVectorField(centerX, centerY, scale) {
            const resolution = parseInt(document.getElementById('field-resolution').value) || 10;
            const fieldType = document.getElementById('field-type').value;
            const customField = document.getElementById('custom-field').value;
            
            const cellSize = Math.min(canvas.width, canvas.height) / resolution;
            
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x = (i - resolution/2) * cellSize / scale;
                    const y = (j - resolution/2) * cellSize / scale;
                    
                    let fieldVector;
                    
                    try {
                        switch(fieldType) {
                            case 'rotation':
                                fieldVector = new Vector3D(-y, x, 0);
                                break;
                            case 'gravity':
                                fieldVector = new Vector3D(0, -9.8, 0);
                                break;
                            case 'custom':
                                // Evaluate custom JavaScript expression
                                const func = new Function('x', 'y', 'z', customField);
                                const result = func(x, y, 0);
                                fieldVector = new Vector3D(result.x, result.y, result.z || 0);
                                break;
                        }
                    } catch (e) {
                        fieldVector = new Vector3D(0, 0, 0);
                    }
                    
                    // Normalize for consistent arrow size
                    const normalized = fieldVector.normalize().scale(cellSize * 0.3);
                    
                    const pos = new Vector3D(x, y, 0);
                    const pos2D = pos.to2D(centerX, centerY, scale);
                    const end2D = pos.add(normalized).to2D(centerX, centerY, scale);
                    
                    // Draw field arrow
                    ctx.strokeStyle = '#4a6fa5';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(pos2D.x, pos2D.y);
                    ctx.lineTo(end2D.x, end2D.y);
                    ctx.stroke();
                    
                    drawArrowhead(pos2D, end2D, '#4a6fa5');
                }
            }
        }
        
        function drawBezierCurve(centerX, centerY, scale) {
            // Get control points
            const cp1 = new Vector3D(
                parseFloat(document.getElementById('cp1-x').value) || 0,
                parseFloat(document.getElementById('cp1-y').value) || 0,
                0
            );
            const cp2 = new Vector3D(
                parseFloat(document.getElementById('cp2-x').value) || 1,
                parseFloat(document.getElementById('cp2-y').value) || 2,
                0
            );
            const cp3 = new Vector3D(
                parseFloat(document.getElementById('cp3-x').value) || 2,
                parseFloat(document.getElementById('cp3-y').value) || 1,
                0
            );
            const cp4 = new Vector3D(
                parseFloat(document.getElementById('cp4-x').value) || 3,
                parseFloat(document.getElementById('cp4-y').value) || 0,
                0
            );
            
            const segments = parseInt(document.getElementById('curve-segments').value) || 50;
            
            // Draw control points
            drawPoint(cp1, centerX, centerY, scale, '#4a6fa5', 'P1');
            drawPoint(cp2, centerX, centerY, scale, '#6b8cbc', 'P2');
            drawPoint(cp3, centerX, centerY, scale, '#6f42c1', 'P3');
            drawPoint(cp4, centerX, centerY, scale, '#20c997', 'P4');
            
            // Draw control polygon
            ctx.strokeStyle = 'rgba(74, 111, 165, 0.3)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;
            
            const cp12D = cp1.to2D(centerX, centerY, scale);
            const cp22D = cp2.to2D(centerX, centerY, scale);
            const cp32D = cp3.to2D(centerX, centerY, scale);
            const cp42D = cp4.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(cp12D.x, cp12D.y);
            ctx.lineTo(cp22D.x, cp22D.y);
            ctx.lineTo(cp32D.x, cp32D.y);
            ctx.lineTo(cp42D.x, cp42D.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw Bézier curve
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                
                // Cubic Bézier formula
                const x = Math.pow(1-t, 3)*cp1.x + 3*Math.pow(1-t, 2)*t*cp2.x + 3*(1-t)*Math.pow(t, 2)*cp3.x + Math.pow(t, 3)*cp4.x;
                const y = Math.pow(1-t, 3)*cp1.y + 3*Math.pow(1-t, 2)*t*cp2.y + 3*(1-t)*Math.pow(t, 2)*cp3.y + Math.pow(t, 3)*cp4.y;
                
                const point = new Vector3D(x, y, 0);
                const point2D = point.to2D(centerX, centerY, scale);
                
                if (i === 0) {
                    ctx.moveTo(point2D.x, point2D.y);
                } else {
                    ctx.lineTo(point2D.x, point2D.y);
                }
            }
            
            ctx.stroke();
        }
        
        // Existing drawing functions (unchanged)
        function drawCoordinateSystem(centerX, centerY, scale) {
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(centerX - scale * 4, centerY);
            ctx.lineTo(centerX + scale * 4, centerY);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - scale * 4);
            ctx.lineTo(centerX, centerY + scale * 4);
            ctx.stroke();
            
            // Z-axis (for 3D view)
            if (is3DView) {
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                // Simplified Z-axis representation
                ctx.moveTo(centerX - scale * 2, centerY - scale * 2);
                ctx.lineTo(centerX + scale * 2, centerY + scale * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Labels
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText('X', centerX + scale * 4 - 10, centerY + 15);
            ctx.fillText('Y', centerX - 15, centerY - scale * 4 + 10);
            if (is3DView) {
                ctx.fillText('Z', centerX + scale * 2 - 5, centerY + scale * 2 + 15);
            }
        }
        
        function drawVector(v, centerX, centerY, scale, color, label) {
            const start = new Vector3D(0, 0, 0);
            const end = v;
            
            const start2D = start.to2D(centerX, centerY, scale);
            const end2D = end.to2D(centerX, centerY, scale);
            
            // Draw vector line
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(start2D.x, start2D.y);
            ctx.lineTo(end2D.x, end2D.y);
            ctx.stroke();
            
            // Draw arrowhead
            drawArrowhead(start2D, end2D, color);
            
            // Draw label
            ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(label, end2D.x + 5, end2D.y - 5);
        }
        
        function drawArrowhead(start, end, color) {
            const headLength = 10;
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const angle = Math.atan2(dy, dx);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(end.x, end.y);
            ctx.lineTo(
                end.x - headLength * Math.cos(angle - Math.PI / 6),
                end.y - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                end.x - headLength * Math.cos(angle + Math.PI / 6),
                end.y - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();
        }
        
        function drawParallelogram(v1, v2, centerX, centerY, scale) {
            ctx.strokeStyle = 'rgba(74, 111, 165, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            const origin = new Vector3D(0, 0, 0);
            const p1 = v1;
            const p2 = v2;
            const p3 = v1.add(v2);
            
            const o2D = origin.to2D(centerX, centerY, scale);
            const p12D = p1.to2D(centerX, centerY, scale);
            const p22D = p2.to2D(centerX, centerY, scale);
            const p32D = p3.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(o2D.x, o2D.y);
            ctx.lineTo(p12D.x, p12D.y);
            ctx.lineTo(p32D.x, p32D.y);
            ctx.lineTo(p22D.x, p22D.y);
            ctx.closePath();
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        function drawReflection(original, axis, reflected, centerX, centerY, scale) {
            // Draw reflection line/plane
            ctx.strokeStyle = 'rgba(111, 66, 193, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            
            const axisEnd = axis.scale(5); // Extend axis for visualization
            const start2D = new Vector3D(0, 0, 0).to2D(centerX, centerY, scale);
            const end2D = axisEnd.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(start2D.x, start2D.y);
            ctx.lineTo(end2D.x, end2D.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw dashed line from original to reflected
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.setLineDash([5, 5]);
            
            const original2D = original.to2D(centerX, centerY, scale);
            const reflected2D = reflected.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(original2D.x, original2D.y);
            ctx.lineTo(reflected2D.x, reflected2D.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawPoint(p, centerX, centerY, scale, color, label) {
            const p2D = p.to2D(centerX, centerY, scale);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(p2D.x, p2D.y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = color;
            ctx.font = '12px Arial';
            ctx.fillText(label, p2D.x + 8, p2D.y - 8);
        }
        
        function drawTriangle(v1, v2, v3, centerX, centerY, scale) {
            ctx.strokeStyle = 'rgba(74, 111, 165, 0.5)';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(74, 111, 165, 0.1)';
            
            const v12D = v1.to2D(centerX, centerY, scale);
            const v22D = v2.to2D(centerX, centerY, scale);
            const v32D = v3.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(v12D.x, v12D.y);
            ctx.lineTo(v22D.x, v22D.y);
            ctx.lineTo(v32D.x, v32D.y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        
        function drawVectorComponents(v, centerX, centerY, scale) {
            const components = [
                new Vector3D(v.x, 0, 0),
                new Vector3D(0, v.y, 0),
                new Vector3D(0, 0, v.z)
            ];
            
            const colors = ['#4a6fa5', '#6b8cbc', '#6f42c1'];
            const labels = ['X-comp', 'Y-comp', 'Z-comp'];
            
            components.forEach((comp, i) => {
                if (comp.magnitude() > 0) {
                    drawVector(comp, centerX, centerY, scale, colors[i], labels[i]);
                }
            });
        }
        
        function drawProjection(v, onto, centerX, centerY, scale) {
            const proj = v.projectOnto(onto);
            
            // Draw projection line
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.setLineDash([5, 5]);
            
            const v2D = v.to2D(centerX, centerY, scale);
            const proj2D = proj.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(v2D.x, v2D.y);
            ctx.lineTo(proj2D.x, proj2D.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw projection vector
            drawVector(proj, centerX, centerY, scale, '#ff6b6b', 'Proj');
        }
        
        function drawRotationArc(v1, v2, axis, centerX, centerY, scale) {
            const angle = v1.angleBetween(v2);
            const radius = v1.magnitude() * scale * 0.7;
            
            const v12D = v1.to2D(centerX, centerY, scale);
            const v22D = v2.to2D(centerX, centerY, scale);
            
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.7)';
            ctx.lineWidth = 2;
            
            // Calculate arc parameters
            const startAngle = Math.atan2(v12D.y - centerY, v12D.x - centerX);
            const endAngle = Math.atan2(v22D.y - centerY, v22D.x - centerX);
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, startAngle, endAngle);
            ctx.stroke();
            
            // Angle label
            const midAngle = (startAngle + endAngle) / 2;
            const labelX = centerX + (radius + 15) * Math.cos(midAngle);
            const labelY = centerY + (radius + 15) * Math.sin(midAngle);
            
            ctx.fillStyle = '#ff6b6b';
            ctx.font = '12px Arial';
            ctx.fillText(`${angle.toFixed(1)}°`, labelX, labelY);
        }
        
        function drawShearedShape(original, sheared, centerX, centerY, scale) {
            // Draw original and sheared vectors as a parallelogram
            ctx.strokeStyle = 'rgba(74, 111, 165, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            
            const origin = new Vector3D(0, 0, 0);
            const o2D = origin.to2D(centerX, centerY, scale);
            const orig2D = original.to2D(centerX, centerY, scale);
            const shear2D = sheared.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(o2D.x, o2D.y);
            ctx.lineTo(orig2D.x, orig2D.y);
            ctx.lineTo(shear2D.x, shear2D.y);
            ctx.lineTo(o2D.x + (shear2D.x - orig2D.x), o2D.y + (shear2D.y - orig2D.y));
            ctx.closePath();
            ctx.stroke();
            
            ctx.setLineDash([]);
        }
        
        function drawVanishingPoint(centerX, centerY, scale) {
            // Draw a simple horizon line to represent perspective
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.moveTo(0, centerY - scale * 2);
            ctx.lineTo(canvas.width, centerY - scale * 2);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.fillText('Horizon', centerX + 10, centerY - scale * 2 - 5);
        }
        
        function drawRay(origin, direction, centerX, centerY, scale) {
            const rayEnd = direction.scale(5); // Extend ray for visualization
            
            ctx.strokeStyle = '#4a6fa5';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            const origin2D = origin.to2D(centerX, centerY, scale);
            const end2D = rayEnd.to2D(centerX, centerY, scale);
            
            ctx.beginPath();
            ctx.moveTo(origin2D.x, origin2D.y);
            ctx.lineTo(end2D.x, end2D.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Arrowhead
            drawArrowhead(origin2D, end2D, '#4a6fa5');
            
            // Label
            ctx.fillStyle = '#4a6fa5';
            ctx.font = '12px Arial';
            ctx.fillText('Ray', end2D.x + 5, end2D.y - 5);
        }
        
        function drawPlane(point, normal, centerX, centerY, scale) {
            // Draw a simplified representation of a plane
            const planeSize = 3;
            const planeV1 = normal.cross(new Vector3D(0, 0, 1)).normalize().scale(planeSize);
            const planeV2 = normal.cross(planeV1).normalize().scale(planeSize);
            
            const corners = [
                point.add(planeV1).add(planeV2),
                point.add(planeV1).subtract(planeV2),
                point.subtract(planeV1).subtract(planeV2),
                point.subtract(planeV1).add(planeV2)
            ];
            
            ctx.fillStyle = 'rgba(107, 140, 188, 0.2)';
            ctx.strokeStyle = 'rgba(107, 140, 188, 0.5)';
            ctx.lineWidth = 1;
            
            const corners2D = corners.map(corner => corner.to2D(centerX, centerY, scale));
            
            ctx.beginPath();
            ctx.moveTo(corners2D[0].x, corners2D[0].y);
            for (let i = 1; i < corners2D.length; i++) {
                ctx.lineTo(corners2D[i].x, corners2D[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Label
            const point2D = point.to2D(centerX, centerY, scale);
            ctx.fillStyle = '#6b8cbc';
            ctx.font = '12px Arial';
            ctx.fillText('Plane', point2D.x + 5, point2D.y - 5);
        }
        
        function drawPlaneFromVectors(v1, v2, centerX, centerY, scale) {
            // Draw a plane defined by two vectors
            const corners = [
                new Vector3D(0, 0, 0),
                v1,
                v1.add(v2),
                v2
            ];
            
            ctx.fillStyle = 'rgba(107, 140, 188, 0.2)';
            ctx.strokeStyle = 'rgba(107, 140, 188, 0.5)';
            ctx.lineWidth = 1;
            
            const corners2D = corners.map(corner => corner.to2D(centerX, centerY, scale));
            
            ctx.beginPath();
            ctx.moveTo(corners2D[0].x, corners2D[0].y);
            for (let i = 1; i < corners2D.length; i++) {
                ctx.lineTo(corners2D[i].x, corners2D[i].y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        // Track operation history
function addToOperationHistory(operation, vectors) {
    operationHistory.push({
        operation,
        vectors: {
            a: { x: vectors.a.x, y: vectors.a.y, z: vectors.a.z },
            b: { x: vectors.b.x, y: vectors.b.y, z: vectors.b.z },
            c: vectors.c ? { x: vectors.c.x, y: vectors.c.y, z: vectors.c.z } : null
        },
        timestamp: new Date().toISOString()
    });
    
    // Keep only last 10 operations
    if (operationHistory.length > 10) {
        operationHistory.shift();
    }
}

// AI Suggestion Engine
function generateAISuggestions() {
    const suggestions = analyzeUsagePatterns();
    
    aiSuggestionsList.innerHTML = '';
    
    suggestions.forEach(suggestion => {
        const chip = document.createElement('div');
        chip.className = 'suggestion-chip';
        chip.textContent = suggestion.operation;
        chip.title = suggestion.reason;
        
        chip.addEventListener('click', () => {
            // Find and activate the corresponding operation button
            const opButton = document.querySelector(`[data-operation="${suggestion.operation}"]`);
            if (opButton) {
                opButton.click();
                commandFeedback.textContent = `✅ Activated: ${suggestion.operation}`;
                commandFeedback.style.color = 'var(--success)';
            }
        });
        
        aiSuggestionsList.appendChild(chip);
    });
}

function analyzeUsagePatterns() {
    if (operationHistory.length === 0) {
        return getDefaultSuggestions();
    }
    
    const recentOps = operationHistory.slice(-5);
    const opCounts = {};
    const vectorPatterns = [];
    
    // Analyze frequency and patterns
    recentOps.forEach(op => {
        opCounts[op.operation] = (opCounts[op.operation] || 0) + 1;
        
        // Analyze vector characteristics
        const magA = Math.sqrt(op.vectors.a.x**2 + op.vectors.a.y**2 + op.vectors.a.z**2);
        const magB = Math.sqrt(op.vectors.b.x**2 + op.vectors.b.y**2 + op.vectors.b.z**2);
        vectorPatterns.push({ magA, magB });
    });
    
    // Generate suggestions based on patterns
    const suggestions = new Set();
    
    // Suggest related operations
    recentOps.forEach(op => {
        const related = getRelatedOperations(op.operation);
        related.forEach(relOp => suggestions.add(relOp));
    });
    
    // Suggest complementary operations based on vector properties
    const avgMagA = vectorPatterns.reduce((sum, p) => sum + p.magA, 0) / vectorPatterns.length;
    const avgMagB = vectorPatterns.reduce((sum, p) => sum + p.magB, 0) / vectorPatterns.length;
    
    if (avgMagA > 5 || avgMagB > 5) {
        suggestions.add('decomposition');
    }
    
    if (recentOps.some(op => op.operation.includes('rotation'))) {
        suggestions.add('quaternionRotation');
    }
    
    if (recentOps.some(op => op.operation.includes('reflection') || op.operation.includes('projection'))) {
        suggestions.add('gramSchmidt');
    }
    
    return Array.from(suggestions).slice(0, 6).map(op => ({
        operation: op,
        reason: getSuggestionReason(op)
    }));
}

function getRelatedOperations(operation) {
    const relatedMap = {
        '3dAddition': ['decomposition', 'gramSchmidt'],
        'reflection': ['rotation', 'normalVector'],
        'rotation': ['quaternionRotation', 'matrixTransformation'],
        'decomposition': ['gramSchmidt', 'eigenDecomposition'],
        'gramSchmidt': ['decomposition', 'eigenDecomposition'],
        'normalVector': ['rayIntersection', 'reflection'],
        'physicsSandbox': ['vectorField', 'advancedCurves']
    };
    
    return relatedMap[operation] || ['3dAddition', 'reflection', 'rotation'];
}

function getDefaultSuggestions() {
    return [
        { operation: '3dAddition', reason: 'Basic vector operation to start with' },
        { operation: 'rotation', reason: 'Common 3D transformation' },
        { operation: 'reflection', reason: 'Learn about vector mirroring' },
        { operation: 'decomposition', reason: 'Understand vector components' },
        { operation: 'physicsSandbox', reason: 'Interactive physics simulation' },
        { operation: 'vectorField', reason: 'Advanced field visualization' }
    ];
}

function getSuggestionReason(operation) {
    const reasons = {
        '3dAddition': 'Builds on basic vector concepts',
        'reflection': 'Related to your recent transformation work',
        'rotation': 'Extends your 3D operation experience',
        'decomposition': 'Helps understand vector components',
        'gramSchmidt': 'Advanced orthogonalization technique',
        'quaternionRotation': 'More robust 3D rotation method',
        'physicsSandbox': 'Interactive application of vectors',
        'vectorField': 'Visualize vector distributions'
    };
    
    return reasons[operation] || 'Recommended based on your usage patterns';
}

// Natural Language Command Processing
function executeNaturalLanguageCommand() {
    const command = nlCommandInput.value.trim();
    if (!command) return;
    
    commandFeedback.textContent = "Processing command...";
    commandFeedback.style.color = 'var(--info)';
    
    // Simple command parsing (in a real implementation, this would use NLP/AI)
    const parsed = parseNaturalLanguageCommand(command);
    
    if (parsed.success) {
        executeParsedCommand(parsed);
        commandFeedback.textContent = "✅ Command executed successfully!";
        commandFeedback.style.color = 'var(--success)';
    } else {
        commandFeedback.textContent = "❌ Could not understand command. Try simpler phrasing.";
        commandFeedback.style.color = 'var(--accent)';
    }
}

function parseNaturalLanguageCommand(command) {
    const lowerCommand = command.toLowerCase();
    
    // Rotation commands
    if (lowerCommand.includes('rotate')) {
        const vectorMatch = lowerCommand.match(/(vector\s+)?([abc])/i);
        const angleMatch = lowerCommand.match(/(\d+)\s*degrees?/i);
        const axisMatch = lowerCommand.match(/(x|y|z)[\s\-]?axis/i);
        
        if (vectorMatch && angleMatch) {
            const vector = vectorMatch[2].toUpperCase();
            const angle = parseInt(angleMatch[1]);
            const axis = axisMatch ? axisMatch[1].toUpperCase() : 'Z';
            
            return {
                success: true,
                operation: 'rotation',
                parameters: { vector, angle, axis }
            };
        }
    }
    
    // Projection commands
    if (lowerCommand.includes('project') || lowerCommand.includes('projection')) {
        const vectorsMatch = lowerCommand.match(/(vector\s+)?([abc])\s+(onto|on)\s+(vector\s+)?([abc])/i);
        
        if (vectorsMatch) {
            return {
                success: true,
                operation: 'decomposition',
                parameters: { 
                    projection: true,
                    from: vectorsMatch[2].toUpperCase(),
                    onto: vectorsMatch[5].toUpperCase()
                }
            };
        }
    }
    
    // Basic operations
    if (lowerCommand.includes('add') || lowerCommand.includes('addition') || lowerCommand.includes('sum')) {
        return { success: true, operation: '3dAddition' };
    }
    
    if (lowerCommand.includes('cross product') || lowerCommand.includes('normal')) {
        return { success: true, operation: 'normalVector' };
    }
    
    if (lowerCommand.includes('dot product') || lowerCommand.includes('dot')) {
        // This would need custom implementation
        return { success: true, operation: '3dAddition' }; // Fallback
    }
    
    if (lowerCommand.includes('reflect') || lowerCommand.includes('reflection')) {
        return { success: true, operation: 'reflection' };
    }
    
    return { success: false, error: "Command not recognized" };
}

function executeParsedCommand(parsed) {
    switch (parsed.operation) {
        case 'rotation':
            executeRotationCommand(parsed.parameters);
            break;
        case 'decomposition':
            executeProjectionCommand(parsed.parameters);
            break;
        default:
            // Activate the operation button
            const opButton = document.querySelector(`[data-operation="${parsed.operation}"]`);
            if (opButton) {
                opButton.click();
                calculateOperation();
            }
    }
}

function executeRotationCommand(params) {
    // Set the vector values based on command
    if (params.vector === 'A') {
        // Vector A is already the primary vector for rotation
    } else if (params.vector === 'B') {
        // Swap vectors for rotation
        document.getElementById('a-x').value = document.getElementById('b-x').value;
        document.getElementById('a-y').value = document.getElementById('b-y').value;
        document.getElementById('a-z').value = document.getElementById('b-z').value;
    }
    
    // Set rotation angle
    document.getElementById('angle-value').value = params.angle;
    
    // Set rotation axis
    const axisMap = { X: [1,0,0], Y: [0,1,0], Z: [0,0,1] };
    const axisValues = axisMap[params.axis] || [0,0,1];
    
    document.getElementById('axis-x').value = axisValues[0];
    document.getElementById('axis-y').value = axisValues[1];
    document.getElementById('axis-z').value = axisValues[2];
    
    // Activate rotation operation
    document.querySelector('[data-operation="rotation"]').click();
    updateVectors();
}

function executeProjectionCommand(params) {
    // This would set up the vectors for projection visualization
    document.querySelector('[data-operation="decomposition"]').click();
    updateVectors();
}

// Voice Recognition
function startVoiceRecognition() {
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        commandFeedback.textContent = "❌ Voice recognition not supported in this browser";
        commandFeedback.style.color = 'var(--accent)';
        return;
    }
    
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = new SpeechRecognition();
    
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.lang = 'en-US';
    
    voiceCommandBtn.classList.add('recording');
    commandFeedback.textContent = "🎤 Listening... Speak now";
    commandFeedback.style.color = 'var(--info)';
    
    recognition.start();
    
    recognition.onresult = function(event) {
        const transcript = event.results[0][0].transcript;
        nlCommandInput.value = transcript;
        voiceCommandBtn.classList.remove('recording');
        commandFeedback.textContent = "✅ Voice captured. Click Execute to run command.";
    };
    
    recognition.onerror = function(event) {
        voiceCommandBtn.classList.remove('recording');
        commandFeedback.textContent = "❌ Error in voice recognition";
        commandFeedback.style.color = 'var(--accent)';
    };
    
    recognition.onend = function() {
        voiceCommandBtn.classList.remove('recording');
    };
}

function clearCommand() {
    nlCommandInput.value = '';
    commandFeedback.textContent = '';
}

// AI Explanations
function toggleAIExplanations() {
    aiExplanationsEnabled = aiExplanationsToggle.checked;
    aiExplanationBox.style.display = aiExplanationsEnabled ? 'block' : 'none';
    
    if (aiExplanationsEnabled) {
        generateAIExplanation();
    }
}

function generateAIExplanation() {
    if (!aiExplanationsEnabled) return;
    
    const explanation = createAIExplanation(currentOperation, vectorA, vectorB);
    aiExplanationBox.innerHTML = explanation;
}

function createAIExplanation(operation, vecA, vecB) {
    const explanations = {
        '3dAddition': `
            <h4>Understanding Vector Addition</h4>
            <p>Vector addition works by <strong>combining corresponding components</strong>. 
            Think of it as walking in one direction, then another - the result is your final position.</p>
            <p><strong>Real-world example:</strong> If you walk 3 meters east (Vector A) then 4 meters north (Vector B), 
            your total displacement is the diagonal path combining both movements.</p>
            <p><strong>Mathematically:</strong> (${vecA.x}, ${vecA.y}, ${vecA.z}) + (${vecB.x}, ${vecB.y}, ${vecB.z}) = 
            (${vecA.x + vecB.x}, ${vecA.y + vecB.y}, ${vecA.z + vecB.z})</p>
        `,
        
        'reflection': `
            <h4>How Vector Reflection Works</h4>
            <p>Reflection creates a <strong>mirror image</strong> of a vector across a line or plane. 
            The key insight is that the component perpendicular to the reflection surface gets reversed.</p>
            <p><strong>Visual analogy:</strong> Imagine a ball bouncing off a wall. The reflection follows the 
            "angle of incidence equals angle of reflection" principle.</p>
            <p><strong>Formula:</strong> reflected = original - 2×(original·normal)×normal</p>
        `,
        
        'rotation': `
            <h4>Vector Rotation in 3D Space</h4>
            <p>Rotation transforms a vector by spinning it around an axis. Unlike 2D rotation (which has just one axis), 
            3D rotation can occur around any direction in space.</p>
            <p><strong>Practical use:</strong> This is how 3D graphics engines rotate objects in games and simulations. 
            Each rotation preserves the vector's length but changes its direction.</p>
            <p><strong>Key property:</strong> Rotations are <em>length-preserving</em> transformations.</p>
        `,
        
        'crossProduct': `
            <h4>The Cross Product: Finding perpendicular vectors</h4>
            <p>The cross product of two vectors gives a <strong>third vector perpendicular to both</strong>. 
            Its magnitude represents the area of the parallelogram they form.</p>
            <p><strong>Right-hand rule:</strong> Point fingers in direction of first vector, curl toward second vector - 
            your thumb points in the cross product direction.</p>
            <p><strong>Applications:</strong> Torque in physics, surface normals in computer graphics, 
            and electromagnetic force calculations.</p>
        `
    };
    
    return explanations[operation] || `
        <h4>About ${operation}</h4>
        <p>This operation demonstrates advanced vector mathematics. The visualization shows how vectors interact 
        in multidimensional space, providing intuition for complex mathematical concepts.</p>
        <p>Watch how the vectors change as you modify their components or apply different operations.</p>
    `;
}
        // Initialize with first operation
        updateVectors();
    </script>
</body>
</html>